"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyContextProviderPlugin = void 0;
const sdk_provider_1 = require("../api/aws-auth/sdk-provider");
const logging_1 = require("../logging");
class KeyContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const kms = (await (0, sdk_provider_1.initContextProviderSdk)(this.aws, args)).kms();
        const aliasListEntry = await this.findKey(kms, args);
        return this.readKeyProps(aliasListEntry, args);
    }
    async findKey(kms, args) {
        (0, logging_1.debug)(`Listing keys in ${args.account}:${args.region}`);
        let response;
        let nextMarker;
        do {
            response = await kms.listAliases({
                Marker: nextMarker,
            }).promise();
            const aliases = response.Aliases || [];
            for (const alias of aliases) {
                if (alias.AliasName == args.aliasName) {
                    return alias;
                }
            }
            nextMarker = response.NextMarker;
        } while (response.Truncated);
        const suppressError = 'ignoreErrorOnMissingContext' in args && args.ignoreErrorOnMissingContext;
        const hasDummyKeyId = 'dummyValue' in args && typeof args.dummyValue === 'object' && args.dummyValue !== null && 'keyId' in args.dummyValue;
        if (suppressError && hasDummyKeyId) {
            const keyId = args.dummyValue.keyId;
            return { TargetKeyId: keyId };
        }
        throw new Error(`Could not find any key with alias named ${args.aliasName}`);
    }
    async readKeyProps(alias, args) {
        if (!alias.TargetKeyId) {
            throw new Error(`Could not find any key with alias named ${args.aliasName}`);
        }
        (0, logging_1.debug)(`Key found ${alias.TargetKeyId}`);
        return {
            keyId: alias.TargetKeyId,
        };
    }
}
exports.KeyContextProviderPlugin = KeyContextProviderPlugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImtleXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBSUEsK0RBQW1GO0FBRW5GLHdDQUFtQztBQUVuQyxNQUFhLHdCQUF3QjtJQUVuQyxZQUE2QixHQUFnQjtRQUFoQixRQUFHLEdBQUgsR0FBRyxDQUFhO0lBQzdDLENBQUM7SUFFTSxLQUFLLENBQUMsUUFBUSxDQUFDLElBQThCO1FBQ2xELE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxJQUFBLHFDQUFzQixFQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUVqRSxNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXJELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBWSxFQUFFLElBQThCO1FBRWhFLElBQUEsZUFBSyxFQUFDLG1CQUFtQixJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBRXhELElBQUksUUFBa0UsQ0FBQztRQUN2RSxJQUFJLFVBQThCLENBQUM7UUFDbkMsR0FBRyxDQUFDO1lBQ0YsUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLFdBQVcsQ0FBQztnQkFDL0IsTUFBTSxFQUFFLFVBQVU7YUFDbkIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRWIsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7WUFDdkMsS0FBSyxNQUFNLEtBQUssSUFBSSxPQUFPLEVBQUUsQ0FBQztnQkFDNUIsSUFBSSxLQUFLLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFDdEMsT0FBTyxLQUFLLENBQUM7Z0JBQ2YsQ0FBQztZQUNILENBQUM7WUFFRCxVQUFVLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUNuQyxDQUFDLFFBQVEsUUFBUSxDQUFDLFNBQVMsRUFBRTtRQUU3QixNQUFNLGFBQWEsR0FBRyw2QkFBNkIsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLDJCQUFzQyxDQUFDO1FBQzNHLE1BQU0sYUFBYSxHQUFHLFlBQVksSUFBSSxJQUFJLElBQUksT0FBTyxJQUFJLENBQUMsVUFBVSxLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUM1SSxJQUFJLGFBQWEsSUFBSSxhQUFhLEVBQUUsQ0FBQztZQUNuQyxNQUFNLEtBQUssR0FBSSxJQUFJLENBQUMsVUFBZ0MsQ0FBQyxLQUFLLENBQUM7WUFDM0QsT0FBTyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsQ0FBQztRQUNoQyxDQUFDO1FBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVPLEtBQUssQ0FBQyxZQUFZLENBQUMsS0FBNkIsRUFBRSxJQUE4QjtRQUN0RixJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQy9FLENBQUM7UUFFRCxJQUFBLGVBQUssRUFBQyxhQUFhLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBRXhDLE9BQU87WUFDTCxLQUFLLEVBQUUsS0FBSyxDQUFDLFdBQVc7U0FDekIsQ0FBQztJQUNKLENBQUM7Q0FFRjtBQXZERCw0REF1REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IFByb21pc2VSZXN1bHQgfSBmcm9tICdhd3Mtc2RrL2xpYi9yZXF1ZXN0JztcbmltcG9ydCB7IFNka1Byb3ZpZGVyLCBpbml0Q29udGV4dFByb3ZpZGVyU2RrIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbmV4cG9ydCBjbGFzcyBLZXlDb250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBTZGtQcm92aWRlcikge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFZhbHVlKGFyZ3M6IGN4c2NoZW1hLktleUNvbnRleHRRdWVyeSkge1xuICAgIGNvbnN0IGttcyA9IChhd2FpdCBpbml0Q29udGV4dFByb3ZpZGVyU2RrKHRoaXMuYXdzLCBhcmdzKSkua21zKCk7XG5cbiAgICBjb25zdCBhbGlhc0xpc3RFbnRyeSA9IGF3YWl0IHRoaXMuZmluZEtleShrbXMsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVhZEtleVByb3BzKGFsaWFzTGlzdEVudHJ5LCBhcmdzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZEtleShrbXM6IEFXUy5LTVMsIGFyZ3M6IGN4c2NoZW1hLktleUNvbnRleHRRdWVyeSk6IFByb21pc2U8QVdTLktNUy5BbGlhc0xpc3RFbnRyeT4ge1xuXG4gICAgZGVidWcoYExpc3Rpbmcga2V5cyBpbiAke2FyZ3MuYWNjb3VudH06JHthcmdzLnJlZ2lvbn1gKTtcblxuICAgIGxldCByZXNwb25zZTogUHJvbWlzZVJlc3VsdDxBV1MuS01TLkxpc3RBbGlhc2VzUmVzcG9uc2UsIEFXUy5BV1NFcnJvcj47XG4gICAgbGV0IG5leHRNYXJrZXI6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBkbyB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGttcy5saXN0QWxpYXNlcyh7XG4gICAgICAgIE1hcmtlcjogbmV4dE1hcmtlcixcbiAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgY29uc3QgYWxpYXNlcyA9IHJlc3BvbnNlLkFsaWFzZXMgfHwgW107XG4gICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgaWYgKGFsaWFzLkFsaWFzTmFtZSA9PSBhcmdzLmFsaWFzTmFtZSkge1xuICAgICAgICAgIHJldHVybiBhbGlhcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0TWFya2VyID0gcmVzcG9uc2UuTmV4dE1hcmtlcjtcbiAgICB9IHdoaWxlIChyZXNwb25zZS5UcnVuY2F0ZWQpO1xuXG4gICAgY29uc3Qgc3VwcHJlc3NFcnJvciA9ICdpZ25vcmVFcnJvck9uTWlzc2luZ0NvbnRleHQnIGluIGFyZ3MgJiYgYXJncy5pZ25vcmVFcnJvck9uTWlzc2luZ0NvbnRleHQgYXMgYm9vbGVhbjtcbiAgICBjb25zdCBoYXNEdW1teUtleUlkID0gJ2R1bW15VmFsdWUnIGluIGFyZ3MgJiYgdHlwZW9mIGFyZ3MuZHVtbXlWYWx1ZSA9PT0gJ29iamVjdCcgJiYgYXJncy5kdW1teVZhbHVlICE9PSBudWxsICYmICdrZXlJZCcgaW4gYXJncy5kdW1teVZhbHVlO1xuICAgIGlmIChzdXBwcmVzc0Vycm9yICYmIGhhc0R1bW15S2V5SWQpIHtcbiAgICAgIGNvbnN0IGtleUlkID0gKGFyZ3MuZHVtbXlWYWx1ZSBhcyB7IGtleUlkOiBzdHJpbmcgfSkua2V5SWQ7XG4gICAgICByZXR1cm4geyBUYXJnZXRLZXlJZDoga2V5SWQgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkga2V5IHdpdGggYWxpYXMgbmFtZWQgJHthcmdzLmFsaWFzTmFtZX1gKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVhZEtleVByb3BzKGFsaWFzOiBBV1MuS01TLkFsaWFzTGlzdEVudHJ5LCBhcmdzOiBjeHNjaGVtYS5LZXlDb250ZXh0UXVlcnkpOiBQcm9taXNlPGN4YXBpLktleUNvbnRleHRSZXNwb25zZT4ge1xuICAgIGlmICghYWxpYXMuVGFyZ2V0S2V5SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IGtleSB3aXRoIGFsaWFzIG5hbWVkICR7YXJncy5hbGlhc05hbWV9YCk7XG4gICAgfVxuXG4gICAgZGVidWcoYEtleSBmb3VuZCAke2FsaWFzLlRhcmdldEtleUlkfWApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUlkOiBhbGlhcy5UYXJnZXRLZXlJZCxcbiAgICB9O1xuICB9XG5cbn1cbiJdfQ==