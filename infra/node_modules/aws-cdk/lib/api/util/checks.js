"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBootstrapStackInfo = exports.determineAllowCrossAccountAssetPublishing = void 0;
const logging_1 = require("../../logging");
async function determineAllowCrossAccountAssetPublishing(sdk, customStackName) {
    try {
        const stackName = customStackName || 'CDKToolkit';
        const stackInfo = await getBootstrapStackInfo(sdk, stackName);
        if (!stackInfo.hasStagingBucket) {
            // indicates an intentional cross account setup
            return true;
        }
        if (stackInfo.bootstrapVersion >= 21) {
            // bootstrap stack version 21 contains a fix that will prevent cross
            // account publishing on the IAM level
            // https://github.com/aws/aws-cdk/pull/30823
            return true;
        }
        // If there is a staging bucket AND the bootstrap version is old, then we want to protect
        // against accidental cross-account publishing.
        return false;
    }
    catch (e) {
        // You would think we would need to fail closed here, but the reality is
        // that we get here if we couldn't find the bootstrap stack: that is
        // completely valid, and many large organizations may have their own method
        // of creating bootstrap resources. If they do, there's nothing for us to validate,
        // but we can't use that as a reason to disallow cross-account publishing. We'll just
        // have to trust they did their due diligence. So we fail open.
        (0, logging_1.debug)(`Error determining cross account asset publishing: ${e}`);
        (0, logging_1.debug)('Defaulting to allowing cross account asset publishing');
        return true;
    }
}
exports.determineAllowCrossAccountAssetPublishing = determineAllowCrossAccountAssetPublishing;
async function getBootstrapStackInfo(sdk, stackName) {
    try {
        const cfn = sdk.cloudFormation();
        const stackResponse = await cfn.describeStacks({ StackName: stackName }).promise();
        if (!stackResponse.Stacks || stackResponse.Stacks.length === 0) {
            throw new Error(`Toolkit stack ${stackName} not found`);
        }
        const stack = stackResponse.Stacks[0];
        const versionOutput = stack.Outputs?.find(output => output.OutputKey === 'BootstrapVersion');
        if (!versionOutput?.OutputValue) {
            throw new Error(`Unable to find BootstrapVersion output in the toolkit stack ${stackName}`);
        }
        const bootstrapVersion = parseInt(versionOutput.OutputValue);
        if (isNaN(bootstrapVersion)) {
            throw new Error(`Invalid BootstrapVersion value: ${versionOutput.OutputValue}`);
        }
        // try to get bucketname from the logical resource id. If there is no
        // bucketname, or the value doesn't look like an S3 bucket name, we assume
        // the bucket doesn't exist (this is for the case where a template customizer did
        // not dare to remove the Output, but put a dummy value there like '' or '-' or '***').
        //
        // We would have preferred to look at the stack resources here, but
        // unfortunately the deploy role doesn't have permissions call DescribeStackResources.
        const bucketName = stack.Outputs?.find(output => output.OutputKey === 'BucketName')?.OutputValue;
        // Must begin and end with letter or number.
        const hasStagingBucket = !!(bucketName && bucketName.match(/^[a-z0-9]/) && bucketName.match(/[a-z0-9]$/));
        return {
            hasStagingBucket,
            bootstrapVersion,
        };
    }
    catch (e) {
        throw new Error(`Error retrieving toolkit stack info: ${e}`);
    }
}
exports.getBootstrapStackInfo = getBootstrapStackInfo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2hlY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJDQUFzQztBQUcvQixLQUFLLFVBQVUseUNBQXlDLENBQUMsR0FBUyxFQUFFLGVBQXdCO0lBQ2pHLElBQUksQ0FBQztRQUNILE1BQU0sU0FBUyxHQUFHLGVBQWUsSUFBSSxZQUFZLENBQUM7UUFDbEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFOUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ2hDLCtDQUErQztZQUMvQyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxJQUFJLFNBQVMsQ0FBQyxnQkFBZ0IsSUFBSSxFQUFFLEVBQUUsQ0FBQztZQUNyQyxvRUFBb0U7WUFDcEUsc0NBQXNDO1lBQ3RDLDRDQUE0QztZQUM1QyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCx5RkFBeUY7UUFDekYsK0NBQStDO1FBQy9DLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFDWCx3RUFBd0U7UUFDeEUsb0VBQW9FO1FBQ3BFLDJFQUEyRTtRQUMzRSxtRkFBbUY7UUFDbkYscUZBQXFGO1FBQ3JGLCtEQUErRDtRQUMvRCxJQUFBLGVBQUssRUFBQyxxREFBcUQsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNoRSxJQUFBLGVBQUssRUFBQyx1REFBdUQsQ0FBQyxDQUFDO1FBQy9ELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUM7QUEvQkQsOEZBK0JDO0FBT00sS0FBSyxVQUFVLHFCQUFxQixDQUFDLEdBQVMsRUFBRSxTQUFpQjtJQUN0RSxJQUFJLENBQUM7UUFDSCxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDakMsTUFBTSxhQUFhLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFbkYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLElBQUksYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDL0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsU0FBUyxZQUFZLENBQUMsQ0FBQztRQUMxRCxDQUFDO1FBRUQsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEtBQUssa0JBQWtCLENBQUMsQ0FBQztRQUU3RixJQUFJLENBQUMsYUFBYSxFQUFFLFdBQVcsRUFBRSxDQUFDO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0RBQStELFNBQVMsRUFBRSxDQUFDLENBQUM7UUFDOUYsQ0FBQztRQUVELE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM3RCxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFDbEYsQ0FBQztRQUVELHFFQUFxRTtRQUNyRSwwRUFBMEU7UUFDMUUsaUZBQWlGO1FBQ2pGLHVGQUF1RjtRQUN2RixFQUFFO1FBQ0YsbUVBQW1FO1FBQ25FLHNGQUFzRjtRQUN0RixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEtBQUssWUFBWSxDQUFDLEVBQUUsV0FBVyxDQUFDO1FBQ2pHLDRDQUE0QztRQUM1QyxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUUxRyxPQUFPO1lBQ0wsZ0JBQWdCO1lBQ2hCLGdCQUFnQjtTQUNqQixDQUFDO0lBQ0osQ0FBQztJQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQy9ELENBQUM7QUFDSCxDQUFDO0FBdkNELHNEQXVDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgvc2RrJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZUFsbG93Q3Jvc3NBY2NvdW50QXNzZXRQdWJsaXNoaW5nKHNkazogSVNESywgY3VzdG9tU3RhY2tOYW1lPzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhY2tOYW1lID0gY3VzdG9tU3RhY2tOYW1lIHx8ICdDREtUb29sa2l0JztcbiAgICBjb25zdCBzdGFja0luZm8gPSBhd2FpdCBnZXRCb290c3RyYXBTdGFja0luZm8oc2RrLCBzdGFja05hbWUpO1xuXG4gICAgaWYgKCFzdGFja0luZm8uaGFzU3RhZ2luZ0J1Y2tldCkge1xuICAgICAgLy8gaW5kaWNhdGVzIGFuIGludGVudGlvbmFsIGNyb3NzIGFjY291bnQgc2V0dXBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdGFja0luZm8uYm9vdHN0cmFwVmVyc2lvbiA+PSAyMSkge1xuICAgICAgLy8gYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gMjEgY29udGFpbnMgYSBmaXggdGhhdCB3aWxsIHByZXZlbnQgY3Jvc3NcbiAgICAgIC8vIGFjY291bnQgcHVibGlzaGluZyBvbiB0aGUgSUFNIGxldmVsXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvcHVsbC8zMDgyM1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBzdGFnaW5nIGJ1Y2tldCBBTkQgdGhlIGJvb3RzdHJhcCB2ZXJzaW9uIGlzIG9sZCwgdGhlbiB3ZSB3YW50IHRvIHByb3RlY3RcbiAgICAvLyBhZ2FpbnN0IGFjY2lkZW50YWwgY3Jvc3MtYWNjb3VudCBwdWJsaXNoaW5nLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFlvdSB3b3VsZCB0aGluayB3ZSB3b3VsZCBuZWVkIHRvIGZhaWwgY2xvc2VkIGhlcmUsIGJ1dCB0aGUgcmVhbGl0eSBpc1xuICAgIC8vIHRoYXQgd2UgZ2V0IGhlcmUgaWYgd2UgY291bGRuJ3QgZmluZCB0aGUgYm9vdHN0cmFwIHN0YWNrOiB0aGF0IGlzXG4gICAgLy8gY29tcGxldGVseSB2YWxpZCwgYW5kIG1hbnkgbGFyZ2Ugb3JnYW5pemF0aW9ucyBtYXkgaGF2ZSB0aGVpciBvd24gbWV0aG9kXG4gICAgLy8gb2YgY3JlYXRpbmcgYm9vdHN0cmFwIHJlc291cmNlcy4gSWYgdGhleSBkbywgdGhlcmUncyBub3RoaW5nIGZvciB1cyB0byB2YWxpZGF0ZSxcbiAgICAvLyBidXQgd2UgY2FuJ3QgdXNlIHRoYXQgYXMgYSByZWFzb24gdG8gZGlzYWxsb3cgY3Jvc3MtYWNjb3VudCBwdWJsaXNoaW5nLiBXZSdsbCBqdXN0XG4gICAgLy8gaGF2ZSB0byB0cnVzdCB0aGV5IGRpZCB0aGVpciBkdWUgZGlsaWdlbmNlLiBTbyB3ZSBmYWlsIG9wZW4uXG4gICAgZGVidWcoYEVycm9yIGRldGVybWluaW5nIGNyb3NzIGFjY291bnQgYXNzZXQgcHVibGlzaGluZzogJHtlfWApO1xuICAgIGRlYnVnKCdEZWZhdWx0aW5nIHRvIGFsbG93aW5nIGNyb3NzIGFjY291bnQgYXNzZXQgcHVibGlzaGluZycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmludGVyZmFjZSBCb290c3RyYXBTdGFja0luZm8ge1xuICBoYXNTdGFnaW5nQnVja2V0OiBib29sZWFuO1xuICBib290c3RyYXBWZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCb290c3RyYXBTdGFja0luZm8oc2RrOiBJU0RLLCBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Qm9vdHN0cmFwU3RhY2tJbmZvPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2ZuID0gc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG4gICAgY29uc3Qgc3RhY2tSZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZVN0YWNrcyh7IFN0YWNrTmFtZTogc3RhY2tOYW1lIH0pLnByb21pc2UoKTtcblxuICAgIGlmICghc3RhY2tSZXNwb25zZS5TdGFja3MgfHwgc3RhY2tSZXNwb25zZS5TdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2xraXQgc3RhY2sgJHtzdGFja05hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tSZXNwb25zZS5TdGFja3NbMF07XG4gICAgY29uc3QgdmVyc2lvbk91dHB1dCA9IHN0YWNrLk91dHB1dHM/LmZpbmQob3V0cHV0ID0+IG91dHB1dC5PdXRwdXRLZXkgPT09ICdCb290c3RyYXBWZXJzaW9uJyk7XG5cbiAgICBpZiAoIXZlcnNpb25PdXRwdXQ/Lk91dHB1dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIEJvb3RzdHJhcFZlcnNpb24gb3V0cHV0IGluIHRoZSB0b29sa2l0IHN0YWNrICR7c3RhY2tOYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uT3V0cHV0Lk91dHB1dFZhbHVlKTtcbiAgICBpZiAoaXNOYU4oYm9vdHN0cmFwVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCb290c3RyYXBWZXJzaW9uIHZhbHVlOiAke3ZlcnNpb25PdXRwdXQuT3V0cHV0VmFsdWV9YCk7XG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIGdldCBidWNrZXRuYW1lIGZyb20gdGhlIGxvZ2ljYWwgcmVzb3VyY2UgaWQuIElmIHRoZXJlIGlzIG5vXG4gICAgLy8gYnVja2V0bmFtZSwgb3IgdGhlIHZhbHVlIGRvZXNuJ3QgbG9vayBsaWtlIGFuIFMzIGJ1Y2tldCBuYW1lLCB3ZSBhc3N1bWVcbiAgICAvLyB0aGUgYnVja2V0IGRvZXNuJ3QgZXhpc3QgKHRoaXMgaXMgZm9yIHRoZSBjYXNlIHdoZXJlIGEgdGVtcGxhdGUgY3VzdG9taXplciBkaWRcbiAgICAvLyBub3QgZGFyZSB0byByZW1vdmUgdGhlIE91dHB1dCwgYnV0IHB1dCBhIGR1bW15IHZhbHVlIHRoZXJlIGxpa2UgJycgb3IgJy0nIG9yICcqKionKS5cbiAgICAvL1xuICAgIC8vIFdlIHdvdWxkIGhhdmUgcHJlZmVycmVkIHRvIGxvb2sgYXQgdGhlIHN0YWNrIHJlc291cmNlcyBoZXJlLCBidXRcbiAgICAvLyB1bmZvcnR1bmF0ZWx5IHRoZSBkZXBsb3kgcm9sZSBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbnMgY2FsbCBEZXNjcmliZVN0YWNrUmVzb3VyY2VzLlxuICAgIGNvbnN0IGJ1Y2tldE5hbWUgPSBzdGFjay5PdXRwdXRzPy5maW5kKG91dHB1dCA9PiBvdXRwdXQuT3V0cHV0S2V5ID09PSAnQnVja2V0TmFtZScpPy5PdXRwdXRWYWx1ZTtcbiAgICAvLyBNdXN0IGJlZ2luIGFuZCBlbmQgd2l0aCBsZXR0ZXIgb3IgbnVtYmVyLlxuICAgIGNvbnN0IGhhc1N0YWdpbmdCdWNrZXQgPSAhIShidWNrZXROYW1lICYmIGJ1Y2tldE5hbWUubWF0Y2goL15bYS16MC05XS8pICYmIGJ1Y2tldE5hbWUubWF0Y2goL1thLXowLTldJC8pKTtcblxuICAgIHJldHVybiB7XG4gICAgICBoYXNTdGFnaW5nQnVja2V0LFxuICAgICAgYm9vdHN0cmFwVmVyc2lvbixcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciByZXRyaWV2aW5nIHRvb2xraXQgc3RhY2sgaW5mbzogJHtlfWApO1xuICB9XG59Il19