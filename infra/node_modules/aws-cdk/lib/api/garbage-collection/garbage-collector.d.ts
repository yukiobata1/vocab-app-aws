import * as cxapi from '@aws-cdk/cx-api';
import { S3 } from 'aws-sdk';
import { SdkProvider } from '../aws-auth';
export declare class S3Asset {
    private readonly bucket;
    readonly key: string;
    readonly size: number;
    private cached_tags;
    constructor(bucket: string, key: string, size: number);
    fileName(): string;
    allTags(s3: S3): Promise<S3.TagSet>;
    private getTag;
    private hasTag;
    hasIsolatedTag(): boolean;
    isolatedTagBefore(date: Date): boolean;
}
/**
 * Props for the Garbage Collector
 */
interface GarbageCollectorProps {
    /**
     * The action to perform. Specify this if you want to perform a truncated set
     * of actions available.
     */
    readonly action: 'print' | 'tag' | 'delete-tagged' | 'full';
    /**
     * The type of asset to garbage collect.
     */
    readonly type: 's3' | 'ecr' | 'all';
    /**
     * The days an asset must be in isolation before being actually deleted.
     */
    readonly rollbackBufferDays: number;
    /**
     * Refuse deletion of any assets younger than this number of days.
     */
    readonly createdBufferDays: number;
    /**
     * The environment to deploy this stack in
     *
     * The environment on the stack artifact may be unresolved, this one
     * must be resolved.
     */
    readonly resolvedEnvironment: cxapi.Environment;
    /**
     * SDK provider (seeded with default credentials)
     *
     * Will be used to make SDK calls to CloudFormation, S3, and ECR.
     */
    readonly sdkProvider: SdkProvider;
    /**
     * The name of the bootstrap stack to look for.
     *
     * @default DEFAULT_TOOLKIT_STACK_NAME
     */
    readonly bootstrapStackName?: string;
    /**
     * Max wait time for retries in milliseconds (for testing purposes).
     *
     * @default 60000
     */
    readonly maxWaitTime?: number;
    /**
     * Confirm with the user before actual deletion happens
     *
     * @default true
     */
    readonly confirm?: boolean;
}
/**
 * A class to facilitate Garbage Collection of S3 and ECR assets
 */
export declare class GarbageCollector {
    readonly props: GarbageCollectorProps;
    private garbageCollectS3Assets;
    private garbageCollectEcrAssets;
    private permissionToDelete;
    private permissionToTag;
    private bootstrapStackName;
    private maxWaitTime;
    private confirm;
    constructor(props: GarbageCollectorProps);
    /**
     * Perform garbage collection on the resolved environment.
     */
    garbageCollect(): Promise<void>;
    private parallelReadAllTags;
    /**
     * Untag assets that were previously tagged, but now currently referenced.
     * Since this is treated as an implementation detail, we do not print the results in the printer.
     */
    private parallelUntag;
    /**
     * Tag objects in parallel using p-limit. The putObjectTagging API does not
     * support batch tagging so we must handle the parallelism client-side.
     */
    private parallelTag;
    /**
     * Delete objects in parallel. The deleteObjects API supports batches of 1000.
     */
    private parallelDelete;
    private bootstrapBucketName;
    private bootstrapQualifier;
    private numObjectsInBucket;
    /**
     * Generator function that reads objects from the S3 Bucket in batches.
     */
    private readBucketInBatches;
}
export {};
