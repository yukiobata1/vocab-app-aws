"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundStackRefresh = exports.refreshStacks = exports.ActiveAssetCache = void 0;
const util_1 = require("../../../test/util");
const logging_1 = require("../../logging");
class ActiveAssetCache {
    constructor() {
        this.stacks = new Set();
    }
    rememberStack(stackTemplate) {
        this.stacks.add(stackTemplate);
    }
    contains(asset) {
        for (const stack of this.stacks) {
            if (stack.includes(asset)) {
                return true;
            }
        }
        return false;
    }
}
exports.ActiveAssetCache = ActiveAssetCache;
async function paginateSdkCall(cb) {
    let finished = false;
    let nextToken;
    while (!finished) {
        nextToken = await cb(nextToken);
        if (nextToken === undefined) {
            finished = true;
        }
    }
}
/** We cannot operate on REVIEW_IN_PROGRESS stacks because we do not know what the template looks like in this case
 * If we encounter this status, we will wait up to the maxWaitTime before erroring out
 */
async function listStacksNotBeingReviewed(cfn, maxWaitTime, nextToken) {
    let sleepMs = 500;
    const deadline = Date.now() + maxWaitTime;
    while (Date.now() <= deadline) {
        let stacks = await cfn.listStacks({ NextToken: nextToken }).promise();
        if (!stacks.StackSummaries?.some(s => s.StackStatus == 'REVIEW_IN_PROGRESS')) {
            return stacks;
        }
        await (0, util_1.sleep)(Math.floor(Math.random() * sleepMs));
        sleepMs = sleepMs * 2;
    }
    throw new Error(`Stacks still in REVIEW_IN_PROGRESS state after waiting for ${maxWaitTime} ms.`);
}
/**
 * Fetches all relevant stack templates from CloudFormation. It ignores the following stacks:
 * - stacks in DELETE_COMPLETE or DELETE_IN_PROGRESS stage
 * - stacks that are using a different bootstrap qualifier
 *
 * It fails on the following stacks because we cannot get the template and therefore have an imcomplete
 * understanding of what assets are being used.
 * - stacks in REVIEW_IN_PROGRESS stage
 */
async function fetchAllStackTemplates(cfn, maxWaitTime, qualifier) {
    const stackNames = [];
    await paginateSdkCall(async (nextToken) => {
        const stacks = await listStacksNotBeingReviewed(cfn, maxWaitTime, nextToken);
        // We ignore stacks with these statuses because their assets are no longer live
        const ignoredStatues = ['CREATE_FAILED', 'DELETE_COMPLETE', 'DELETE_IN_PROGRESS', 'DELETE_FAILED'];
        stackNames.push(...(stacks.StackSummaries ?? [])
            .filter(s => !ignoredStatues.includes(s.StackStatus))
            .map(s => s.StackId ?? s.StackName));
        return stacks.NextToken;
    });
    (0, logging_1.debug)(`Parsing through ${stackNames.length} stacks`);
    const templates = [];
    for (const stack of stackNames) {
        let summary;
        summary = await cfn.getTemplateSummary({
            StackName: stack,
        }).promise();
        if (bootstrapFilter(summary.Parameters, qualifier)) {
            // This stack is definitely bootstrapped to a different qualifier so we can safely ignore it
            continue;
        }
        else {
            const template = await cfn.getTemplate({
                StackName: stack,
            }).promise();
            templates.push((template.TemplateBody ?? '') + JSON.stringify(summary?.Parameters));
        }
    }
    (0, logging_1.debug)('Done parsing through stacks');
    return templates;
}
/**
 * Filter out stacks that we KNOW are using a different bootstrap qualifier
 * This is mostly necessary for the integration tests that can run the same app (with the same assets)
 * under different qualifiers.
 * This is necessary because a stack under a different bootstrap could coincidentally reference the same hash
 * and cause a false negative (cause an asset to be preserved when its isolated)
 * This is intentionally done in a way where we ONLY filter out stacks that are meant for a different qualifier
 * because we are okay with false positives.
 */
function bootstrapFilter(parameters, qualifier) {
    const bootstrapVersion = parameters?.find((p) => p.ParameterKey === 'BootstrapVersion');
    const splitBootstrapVersion = bootstrapVersion?.DefaultValue?.split('/');
    // We find the qualifier in a specific part of the bootstrap version parameter
    return (qualifier &&
        splitBootstrapVersion &&
        splitBootstrapVersion.length == 4 &&
        splitBootstrapVersion[2] != qualifier);
}
async function refreshStacks(cfn, activeAssets, maxWaitTime, qualifier) {
    try {
        const stacks = await fetchAllStackTemplates(cfn, maxWaitTime, qualifier);
        for (const stack of stacks) {
            activeAssets.rememberStack(stack);
        }
    }
    catch (err) {
        throw new Error(`Error refreshing stacks: ${err}`);
    }
}
exports.refreshStacks = refreshStacks;
/**
 * Class that controls scheduling of the background stack refresh
 */
class BackgroundStackRefresh {
    constructor(props) {
        this.props = props;
        this.queuedPromises = [];
        this.lastRefreshTime = Date.now();
    }
    start() {
        // Since start is going to be called right after the first invocation of refreshStacks,
        // lets wait some time before beginning the background refresh.
        this.timeout = setTimeout(() => this.refresh(), 300000); // 5 minutes
    }
    async refresh() {
        const startTime = Date.now();
        await refreshStacks(this.props.cfn, this.props.activeAssets, this.props.maxWaitTime ?? 60000, this.props.qualifier);
        this.justRefreshedStacks();
        // If the last invocation of refreshStacks takes <5 minutes, the next invocation starts 5 minutes after the last one started.
        // If the last invocation of refreshStacks takes >5 minutes, the next invocation starts immediately.
        this.timeout = setTimeout(() => this.refresh(), Math.max(startTime + 300000 - Date.now(), 0));
    }
    justRefreshedStacks() {
        this.lastRefreshTime = Date.now();
        for (const p of this.queuedPromises.splice(0, this.queuedPromises.length)) {
            p(undefined);
        }
    }
    /**
     * Checks if the last successful background refresh happened within the specified time frame.
     * If the last refresh is older than the specified time frame, it returns a Promise that resolves
     * when the next background refresh completes or rejects if the refresh takes too long.
     */
    noOlderThan(ms) {
        const horizon = Date.now() - ms;
        // The last refresh happened within the time frame
        if (this.lastRefreshTime >= horizon) {
            return Promise.resolve();
        }
        // The last refresh happened earlier than the time frame
        // We will wait for the latest refresh to land or reject if it takes too long
        return Promise.race([
            new Promise(resolve => this.queuedPromises.push(resolve)),
            new Promise((_, reject) => setTimeout(() => reject(new Error('refreshStacks took too long; the background thread likely threw an error')), ms)),
        ]);
    }
    stop() {
        clearTimeout(this.timeout);
    }
}
exports.BackgroundStackRefresh = BackgroundStackRefresh;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stcmVmcmVzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInN0YWNrLXJlZnJlc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsNkNBQTJDO0FBQzNDLDJDQUFzQztBQUV0QyxNQUFhLGdCQUFnQjtJQUE3QjtRQUNtQixXQUFNLEdBQWdCLElBQUksR0FBRyxFQUFFLENBQUM7SUFjbkQsQ0FBQztJQVpRLGFBQWEsQ0FBQyxhQUFxQjtRQUN4QyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRU0sUUFBUSxDQUFDLEtBQWE7UUFDM0IsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDaEMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztRQUNILENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Q0FDRjtBQWZELDRDQWVDO0FBRUQsS0FBSyxVQUFVLGVBQWUsQ0FBQyxFQUF1RDtJQUNwRixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7SUFDckIsSUFBSSxTQUE2QixDQUFDO0lBQ2xDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixTQUFTLEdBQUcsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEMsSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDNUIsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILEtBQUssVUFBVSwwQkFBMEIsQ0FBQyxHQUFtQixFQUFFLFdBQW1CLEVBQUUsU0FBNkI7SUFDL0csSUFBSSxPQUFPLEdBQUcsR0FBRyxDQUFDO0lBQ2xCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxX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RUFBRSxDQUFDO1lBQ3BDLE9BQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzNCLENBQUM7UUFFRCx3REFBd0Q7UUFDeEQsNkVBQTZFO1FBQzdFLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQztZQUNsQixJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pELElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQywwRUFBMEUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDaEosQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLElBQUk7UUFDVCxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLENBQUM7Q0FDRjtBQXpERCx3REF5REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi8uLi8uLi90ZXN0L3V0aWwnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcblxuZXhwb3J0IGNsYXNzIEFjdGl2ZUFzc2V0Q2FjaGUge1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgcHVibGljIHJlbWVtYmVyU3RhY2soc3RhY2tUZW1wbGF0ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5zdGFja3MuYWRkKHN0YWNrVGVtcGxhdGUpO1xuICB9XG5cbiAgcHVibGljIGNvbnRhaW5zKGFzc2V0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHRoaXMuc3RhY2tzKSB7XG4gICAgICBpZiAoc3RhY2suaW5jbHVkZXMoYXNzZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFnaW5hdGVTZGtDYWxsKGNiOiAobmV4dFRva2VuPzogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4pIHtcbiAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gIGxldCBuZXh0VG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgd2hpbGUgKCFmaW5pc2hlZCkge1xuICAgIG5leHRUb2tlbiA9IGF3YWl0IGNiKG5leHRUb2tlbik7XG4gICAgaWYgKG5leHRUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKiBXZSBjYW5ub3Qgb3BlcmF0ZSBvbiBSRVZJRVdfSU5fUFJPR1JFU1Mgc3RhY2tzIGJlY2F1c2Ugd2UgZG8gbm90IGtub3cgd2hhdCB0aGUgdGVtcGxhdGUgbG9va3MgbGlrZSBpbiB0aGlzIGNhc2VcbiAqIElmIHdlIGVuY291bnRlciB0aGlzIHN0YXR1cywgd2Ugd2lsbCB3YWl0IHVwIHRvIHRoZSBtYXhXYWl0VGltZSBiZWZvcmUgZXJyb3Jpbmcgb3V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxpc3RTdGFja3NOb3RCZWluZ1Jldmlld2VkKGNmbjogQ2xvdWRGb3JtYXRpb24sIG1heFdhaXRUaW1lOiBudW1iZXIsIG5leHRUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gIGxldCBzbGVlcE1zID0gNTAwO1xuICBjb25zdCBkZWFkbGluZSA9IERhdGUubm93KCkgKyBtYXhXYWl0VGltZTtcblxuICB3aGlsZSAoRGF0ZS5ub3coKSA8PSBkZWFkbGluZSkge1xuICAgIGxldCBzdGFja3MgPSBhd2FpdCBjZm4ubGlzdFN0YWNrcyh7IE5leHRUb2tlbjogbmV4dFRva2VuIH0pLnByb21pc2UoKTtcbiAgICBpZiAoIXN0YWNrcy5TdGFja1N1bW1hcmllcz8uc29tZShzID0+IHMuU3RhY2tTdGF0dXMgPT0gJ1JFVklFV19JTl9QUk9HUkVTUycpKSB7XG4gICAgICByZXR1cm4gc3RhY2tzO1xuICAgIH1cbiAgICBhd2FpdCBzbGVlcChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzbGVlcE1zKSk7XG4gICAgc2xlZXBNcyA9IHNsZWVwTXMgKiAyO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBTdGFja3Mgc3RpbGwgaW4gUkVWSUVXX0lOX1BST0dSRVNTIHN0YXRlIGFmdGVyIHdhaXRpbmcgZm9yICR7bWF4V2FpdFRpbWV9IG1zLmApO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYWxsIHJlbGV2YW50IHN0YWNrIHRlbXBsYXRlcyBmcm9tIENsb3VkRm9ybWF0aW9uLiBJdCBpZ25vcmVzIHRoZSBmb2xsb3dpbmcgc3RhY2tzOlxuICogLSBzdGFja3MgaW4gREVMRVRFX0NPTVBMRVRFIG9yIERFTEVURV9JTl9QUk9HUkVTUyBzdGFnZVxuICogLSBzdGFja3MgdGhhdCBhcmUgdXNpbmcgYSBkaWZmZXJlbnQgYm9vdHN0cmFwIHF1YWxpZmllclxuICpcbiAqIEl0IGZhaWxzIG9uIHRoZSBmb2xsb3dpbmcgc3RhY2tzIGJlY2F1c2Ugd2UgY2Fubm90IGdldCB0aGUgdGVtcGxhdGUgYW5kIHRoZXJlZm9yZSBoYXZlIGFuIGltY29tcGxldGVcbiAqIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhc3NldHMgYXJlIGJlaW5nIHVzZWQuXG4gKiAtIHN0YWNrcyBpbiBSRVZJRVdfSU5fUFJPR1JFU1Mgc3RhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbGxTdGFja1RlbXBsYXRlcyhjZm46IENsb3VkRm9ybWF0aW9uLCBtYXhXYWl0VGltZTogbnVtYmVyLCBxdWFsaWZpZXI/OiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RhY2tOYW1lczogc3RyaW5nW10gPSBbXTtcbiAgYXdhaXQgcGFnaW5hdGVTZGtDYWxsKGFzeW5jIChuZXh0VG9rZW4pID0+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBsaXN0U3RhY2tzTm90QmVpbmdSZXZpZXdlZChjZm4sIG1heFdhaXRUaW1lLCBuZXh0VG9rZW4pO1xuXG4gICAgLy8gV2UgaWdub3JlIHN0YWNrcyB3aXRoIHRoZXNlIHN0YXR1c2VzIGJlY2F1c2UgdGhlaXIgYXNzZXRzIGFyZSBubyBsb25nZXIgbGl2ZVxuICAgIGNvbnN0IGlnbm9yZWRTdGF0dWVzID0gWydDUkVBVEVfRkFJTEVEJywgJ0RFTEVURV9DT01QTEVURScsICdERUxFVEVfSU5fUFJPR1JFU1MnLCAnREVMRVRFX0ZBSUxFRCddO1xuICAgIHN0YWNrTmFtZXMucHVzaChcbiAgICAgIC4uLihzdGFja3MuU3RhY2tTdW1tYXJpZXMgPz8gW10pXG4gICAgICAgIC5maWx0ZXIocyA9PiAhaWdub3JlZFN0YXR1ZXMuaW5jbHVkZXMocy5TdGFja1N0YXR1cykpXG4gICAgICAgIC5tYXAocyA9PiBzLlN0YWNrSWQgPz8gcy5TdGFja05hbWUpLFxuICAgICk7XG5cbiAgICByZXR1cm4gc3RhY2tzLk5leHRUb2tlbjtcbiAgfSk7XG5cbiAgZGVidWcoYFBhcnNpbmcgdGhyb3VnaCAke3N0YWNrTmFtZXMubGVuZ3RofSBzdGFja3NgKTtcblxuICBjb25zdCB0ZW1wbGF0ZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tOYW1lcykge1xuICAgIGxldCBzdW1tYXJ5O1xuICAgIHN1bW1hcnkgPSBhd2FpdCBjZm4uZ2V0VGVtcGxhdGVTdW1tYXJ5KHtcbiAgICAgIFN0YWNrTmFtZTogc3RhY2ssXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgaWYgKGJvb3RzdHJhcEZpbHRlcihzdW1tYXJ5LlBhcmFtZXRlcnMsIHF1YWxpZmllcikpIHtcbiAgICAgIC8vIFRoaXMgc3RhY2sgaXMgZGVmaW5pdGVseSBib290c3RyYXBwZWQgdG8gYSBkaWZmZXJlbnQgcXVhbGlmaWVyIHNvIHdlIGNhbiBzYWZlbHkgaWdub3JlIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCBjZm4uZ2V0VGVtcGxhdGUoe1xuICAgICAgICBTdGFja05hbWU6IHN0YWNrLFxuICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICB0ZW1wbGF0ZXMucHVzaCgodGVtcGxhdGUuVGVtcGxhdGVCb2R5ID8/ICcnKSArIEpTT04uc3RyaW5naWZ5KHN1bW1hcnk/LlBhcmFtZXRlcnMpKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnRG9uZSBwYXJzaW5nIHRocm91Z2ggc3RhY2tzJyk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlcztcbn1cblxuLyoqXG4gKiBGaWx0ZXIgb3V0IHN0YWNrcyB0aGF0IHdlIEtOT1cgYXJlIHVzaW5nIGEgZGlmZmVyZW50IGJvb3RzdHJhcCBxdWFsaWZpZXJcbiAqIFRoaXMgaXMgbW9zdGx5IG5lY2Vzc2FyeSBmb3IgdGhlIGludGVncmF0aW9uIHRlc3RzIHRoYXQgY2FuIHJ1biB0aGUgc2FtZSBhcHAgKHdpdGggdGhlIHNhbWUgYXNzZXRzKVxuICogdW5kZXIgZGlmZmVyZW50IHF1YWxpZmllcnMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgc3RhY2sgdW5kZXIgYSBkaWZmZXJlbnQgYm9vdHN0cmFwIGNvdWxkIGNvaW5jaWRlbnRhbGx5IHJlZmVyZW5jZSB0aGUgc2FtZSBoYXNoXG4gKiBhbmQgY2F1c2UgYSBmYWxzZSBuZWdhdGl2ZSAoY2F1c2UgYW4gYXNzZXQgdG8gYmUgcHJlc2VydmVkIHdoZW4gaXRzIGlzb2xhdGVkKVxuICogVGhpcyBpcyBpbnRlbnRpb25hbGx5IGRvbmUgaW4gYSB3YXkgd2hlcmUgd2UgT05MWSBmaWx0ZXIgb3V0IHN0YWNrcyB0aGF0IGFyZSBtZWFudCBmb3IgYSBkaWZmZXJlbnQgcXVhbGlmaWVyXG4gKiBiZWNhdXNlIHdlIGFyZSBva2F5IHdpdGggZmFsc2UgcG9zaXRpdmVzLlxuICovXG5mdW5jdGlvbiBib290c3RyYXBGaWx0ZXIocGFyYW1ldGVycz86IENsb3VkRm9ybWF0aW9uLlBhcmFtZXRlckRlY2xhcmF0aW9ucywgcXVhbGlmaWVyPzogc3RyaW5nKSB7XG4gIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJhbWV0ZXJzPy5maW5kKChwKSA9PiBwLlBhcmFtZXRlcktleSA9PT0gJ0Jvb3RzdHJhcFZlcnNpb24nKTtcbiAgY29uc3Qgc3BsaXRCb290c3RyYXBWZXJzaW9uID0gYm9vdHN0cmFwVmVyc2lvbj8uRGVmYXVsdFZhbHVlPy5zcGxpdCgnLycpO1xuICAvLyBXZSBmaW5kIHRoZSBxdWFsaWZpZXIgaW4gYSBzcGVjaWZpYyBwYXJ0IG9mIHRoZSBib290c3RyYXAgdmVyc2lvbiBwYXJhbWV0ZXJcbiAgcmV0dXJuIChxdWFsaWZpZXIgJiZcbiAgICAgICAgICBzcGxpdEJvb3RzdHJhcFZlcnNpb24gJiZcbiAgICAgICAgICBzcGxpdEJvb3RzdHJhcFZlcnNpb24ubGVuZ3RoID09IDQgJiZcbiAgICAgICAgICBzcGxpdEJvb3RzdHJhcFZlcnNpb25bMl0gIT0gcXVhbGlmaWVyKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hTdGFja3MoY2ZuOiBDbG91ZEZvcm1hdGlvbiwgYWN0aXZlQXNzZXRzOiBBY3RpdmVBc3NldENhY2hlLCBtYXhXYWl0VGltZTogbnVtYmVyLCBxdWFsaWZpZXI/OiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBmZXRjaEFsbFN0YWNrVGVtcGxhdGVzKGNmbiwgbWF4V2FpdFRpbWUsIHF1YWxpZmllcik7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3MpIHtcbiAgICAgIGFjdGl2ZUFzc2V0cy5yZW1lbWJlclN0YWNrKHN0YWNrKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmVmcmVzaGluZyBzdGFja3M6ICR7ZXJyfWApO1xuICB9XG59XG5cbi8qKlxuICogQmFja2dyb3VuZCBTdGFjayBSZWZyZXNoIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kU3RhY2tSZWZyZXNoUHJvcHMge1xuICAvKipcbiAgICogVGhlIENGTiBTREsgaGFuZGxlclxuICAgKi9cbiAgcmVhZG9ubHkgY2ZuOiBDbG91ZEZvcm1hdGlvbjtcblxuICAvKipcbiAgICogQWN0aXZlIEFzc2V0IHN0b3JhZ2VcbiAgICovXG4gIHJlYWRvbmx5IGFjdGl2ZUFzc2V0czogQWN0aXZlQXNzZXRDYWNoZTtcblxuICAvKipcbiAgICogU3RhY2sgYm9vdHN0cmFwIHF1YWxpZmllclxuICAgKi9cbiAgcmVhZG9ubHkgcXVhbGlmaWVyPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIHdhaXQgdGltZSB3aGVuIHdhaXRpbmcgZm9yIHN0YWNrcyB0byBsZWF2ZSBSRVZJRVdfSU5fUFJPR1JFU1Mgc3RhZ2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IDYwMDAwXG4gICAqL1xuICByZWFkb25seSBtYXhXYWl0VGltZT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGNvbnRyb2xzIHNjaGVkdWxpbmcgb2YgdGhlIGJhY2tncm91bmQgc3RhY2sgcmVmcmVzaFxuICovXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZFN0YWNrUmVmcmVzaCB7XG4gIHByaXZhdGUgdGltZW91dD86IE5vZGVKUy5UaW1lb3V0O1xuICBwcml2YXRlIGxhc3RSZWZyZXNoVGltZTogbnVtYmVyO1xuICBwcml2YXRlIHF1ZXVlZFByb21pc2VzOiBBcnJheTwodmFsdWU6IHVua25vd24pID0+IHZvaWQ+ID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogQmFja2dyb3VuZFN0YWNrUmVmcmVzaFByb3BzKSB7XG4gICAgdGhpcy5sYXN0UmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0KCkge1xuICAgIC8vIFNpbmNlIHN0YXJ0IGlzIGdvaW5nIHRvIGJlIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiByZWZyZXNoU3RhY2tzLFxuICAgIC8vIGxldHMgd2FpdCBzb21lIHRpbWUgYmVmb3JlIGJlZ2lubmluZyB0aGUgYmFja2dyb3VuZCByZWZyZXNoLlxuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWZyZXNoKCksIDMwMF8wMDApOyAvLyA1IG1pbnV0ZXNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgYXdhaXQgcmVmcmVzaFN0YWNrcyh0aGlzLnByb3BzLmNmbiwgdGhpcy5wcm9wcy5hY3RpdmVBc3NldHMsIHRoaXMucHJvcHMubWF4V2FpdFRpbWUgPz8gNjAwMDAsIHRoaXMucHJvcHMucXVhbGlmaWVyKTtcbiAgICB0aGlzLmp1c3RSZWZyZXNoZWRTdGFja3MoKTtcblxuICAgIC8vIElmIHRoZSBsYXN0IGludm9jYXRpb24gb2YgcmVmcmVzaFN0YWNrcyB0YWtlcyA8NSBtaW51dGVzLCB0aGUgbmV4dCBpbnZvY2F0aW9uIHN0YXJ0cyA1IG1pbnV0ZXMgYWZ0ZXIgdGhlIGxhc3Qgb25lIHN0YXJ0ZWQuXG4gICAgLy8gSWYgdGhlIGxhc3QgaW52b2NhdGlvbiBvZiByZWZyZXNoU3RhY2tzIHRha2VzID41IG1pbnV0ZXMsIHRoZSBuZXh0IGludm9jYXRpb24gc3RhcnRzIGltbWVkaWF0ZWx5LlxuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWZyZXNoKCksIE1hdGgubWF4KHN0YXJ0VGltZSArIDMwMF8wMDAgLSBEYXRlLm5vdygpLCAwKSk7XG4gIH1cblxuICBwcml2YXRlIGp1c3RSZWZyZXNoZWRTdGFja3MoKSB7XG4gICAgdGhpcy5sYXN0UmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnF1ZXVlZFByb21pc2VzLnNwbGljZSgwLCB0aGlzLnF1ZXVlZFByb21pc2VzLmxlbmd0aCkpIHtcbiAgICAgIHAodW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgYmFja2dyb3VuZCByZWZyZXNoIGhhcHBlbmVkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUgZnJhbWUuXG4gICAqIElmIHRoZSBsYXN0IHJlZnJlc2ggaXMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIHRpbWUgZnJhbWUsIGl0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXNcbiAgICogd2hlbiB0aGUgbmV4dCBiYWNrZ3JvdW5kIHJlZnJlc2ggY29tcGxldGVzIG9yIHJlamVjdHMgaWYgdGhlIHJlZnJlc2ggdGFrZXMgdG9vIGxvbmcuXG4gICAqL1xuICBwdWJsaWMgbm9PbGRlclRoYW4obXM6IG51bWJlcikge1xuICAgIGNvbnN0IGhvcml6b24gPSBEYXRlLm5vdygpIC0gbXM7XG5cbiAgICAvLyBUaGUgbGFzdCByZWZyZXNoIGhhcHBlbmVkIHdpdGhpbiB0aGUgdGltZSBmcmFtZVxuICAgIGlmICh0aGlzLmxhc3RSZWZyZXNoVGltZSA+PSBob3Jpem9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxhc3QgcmVmcmVzaCBoYXBwZW5lZCBlYXJsaWVyIHRoYW4gdGhlIHRpbWUgZnJhbWVcbiAgICAvLyBXZSB3aWxsIHdhaXQgZm9yIHRoZSBsYXRlc3QgcmVmcmVzaCB0byBsYW5kIG9yIHJlamVjdCBpZiBpdCB0YWtlcyB0b28gbG9uZ1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLnF1ZXVlZFByb21pc2VzLnB1c2gocmVzb2x2ZSkpLFxuICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdyZWZyZXNoU3RhY2tzIHRvb2sgdG9vIGxvbmc7IHRoZSBiYWNrZ3JvdW5kIHRocmVhZCBsaWtlbHkgdGhyZXcgYW4gZXJyb3InKSksIG1zKSksXG4gICAgXSk7XG4gIH1cblxuICBwdWJsaWMgc3RvcCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgfVxufVxuIl19