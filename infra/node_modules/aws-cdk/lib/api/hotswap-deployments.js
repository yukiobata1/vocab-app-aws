"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = void 0;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const aws_auth_1 = require("./aws-auth");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const logging_1 = require("../logging");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
// Must use a require() otherwise esbuild complains about calling a namespace
// eslint-disable-next-line @typescript-eslint/no-require-imports
const pLimit = require('p-limit');
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::ApiKey': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': async (logicalId, change, evaluateCfnTemplate) => {
        // If the policy is for a S3BucketDeploymentChange, we can ignore the change
        if (await (0, s3_bucket_deployments_1.skipChangeForS3DeployCustomResourcePolicy)(logicalId, change, evaluateCfnTemplate)) {
            return [];
        }
        return (0, common_1.reportNonHotswappableResource)(change, 'This resource type is not supported for hotswap deployments');
    },
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact, hotswapMode, hotswapPropertyOverrides) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(stackArtifact, sdk);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackName: stackArtifact.stackName,
        template: stackArtifact.template,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        urlSuffix: (region) => sdk.getEndpointSuffix(region),
        sdk,
        nestedStacks: currentTemplate.nestedStacks,
    });
    const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedRootTemplate, stackArtifact.template);
    const { hotswappableChanges, nonHotswappableChanges } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStacks, hotswapPropertyOverrides);
    logNonHotswappableChanges(nonHotswappableChanges, hotswapMode);
    // preserve classic hotswap behavior
    if (hotswapMode === common_1.HotswapMode.FALL_BACK) {
        if (nonHotswappableChanges.length > 0) {
            return undefined;
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs };
}
exports.tryHotswapDeployment = tryHotswapDeployment;
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames, hotswapPropertyOverrides) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            reason: 'output was changed',
            logicalId,
            rejectedChanges: [],
            resourceType: 'Stack Output',
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk, hotswapPropertyOverrides);
            hotswappableResources.push(...nestedHotswappableResources.hotswappableChanges);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappableChanges);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(change, logicalId);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate, hotswapPropertyOverrides));
        }
        else {
            (0, common_1.reportNonHotswappableChange)(nonHotswappableResources, hotswappableChangeCandidate, undefined, 'This resource type is not supported for hotswap deployments');
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        // Constant set of promises per resource
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable ?
                hotswappableResources.push(propertyResult) :
                nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappableChanges: hotswappableResources,
        nonHotswappableChanges: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, resChange => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, resChange => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackTemplates, evaluateCfnTemplate, sdk, hotswapPropertyOverrides) {
    const nestedStack = nestedStackTemplates[logicalId];
    if (!nestedStack.physicalName) {
        return {
            hotswappableChanges: [],
            nonHotswappableChanges: [{
                    hotswappable: false,
                    logicalId,
                    reason: `physical name for AWS::CloudFormation::Stack '${logicalId}' could not be found in CloudFormation, so this is a newly created nested stack and cannot be hotswapped`,
                    rejectedChanges: [],
                    resourceType: 'AWS::CloudFormation::Stack',
                }],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStack.physicalName, nestedStack.generatedTemplate, change.newValue?.Properties?.Parameters);
    const nestedDiff = cfn_diff.fullDiff(nestedStackTemplates[logicalId].deployedTemplate, nestedStackTemplates[logicalId].generatedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackTemplates[logicalId].nestedStackTemplates, hotswapPropertyOverrides);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(change, logicalId) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            resourceType: change.newValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was created by this deployment`,
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            resourceType: change.oldValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was destroyed by this deployment`,
        };
    }
    // a resource has had its type changed
    if (change.newValue?.Type !== change.oldValue?.Type) {
        return {
            hotswappable: false,
            resourceType: change.newValue?.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    if (hotswappableChanges.length > 0) {
        (0, logging_1.print)(`\n${common_1.ICON} hotswapping resources:`);
    }
    const limit = pLimit(10);
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(hotswappableChanges.map(hotswapOperation => limit(() => {
        return applyHotswappableChange(sdk, hotswapOperation);
    })));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`   ${common_1.ICON} %s`, chalk.bold(name));
    }
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    await hotswapOperation.apply(sdk);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
    }
    sdk.removeCustomUserAgent(customUserAgent);
}
function logNonHotswappableChanges(nonHotswappableChanges, hotswapMode) {
    if (nonHotswappableChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        nonHotswappableChanges = nonHotswappableChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (nonHotswappableChanges.length === 0) {
            return;
        }
    }
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback'));
    }
    else {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:'));
    }
    for (const change of nonHotswappableChanges) {
        change.rejectedChanges.length > 0 ?
            (0, logging_1.print)('    logicalID: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.bold(change.rejectedChanges), chalk.red(change.reason)) :
            (0, logging_1.print)('    logicalID: %s, type: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.red(change.reason));
    }
    (0, logging_1.print)(''); // newline
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseURBQXlEO0FBRXpELCtCQUErQjtBQUMvQix5Q0FBcUQ7QUFFckQseUZBQW9GO0FBQ3BGLHdDQUFtQztBQUNuQyxtRkFBa0Y7QUFDbEYsdUVBQXFGO0FBQ3JGLDZDQUFtUTtBQUNuUSx5REFBd0U7QUFDeEUsaUVBQWdGO0FBQ2hGLDJFQUFvSTtBQUNwSSx5RkFBMEY7QUFDMUYsaUVBQW1HO0FBR25HLDZFQUE2RTtBQUM3RSxpRUFBaUU7QUFDakUsTUFBTSxNQUFNLEdBQTZCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQVM1RCxNQUFNLGtCQUFrQixHQUF1QztJQUM3RCxTQUFTO0lBQ1QsdUJBQXVCLEVBQUUscURBQWtDO0lBQzNELHNCQUFzQixFQUFFLHFEQUFrQztJQUMxRCxvQkFBb0IsRUFBRSxxREFBa0M7SUFFeEQsVUFBVTtJQUNWLHdCQUF3QixFQUFFLHVEQUEyQjtJQUNyRCxxQ0FBcUMsRUFBRSx1REFBMkI7SUFDbEUsNkJBQTZCLEVBQUUsdURBQTJCO0lBQzFELHNCQUFzQixFQUFFLHVEQUEyQjtJQUVuRCwwQkFBMEIsRUFBRSw2Q0FBOEI7SUFDMUQseUJBQXlCLEVBQUUsMERBQW9DO0lBQy9ELGtDQUFrQyxFQUFFLCtEQUFnQztJQUNwRSw2QkFBNkIsRUFBRSw4REFBc0M7SUFDckUsa0JBQWtCLEVBQUUsS0FBSyxFQUN2QixTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1ELEVBQzdFLEVBQUU7UUFDaEMsNEVBQTRFO1FBQzVFLElBQUksTUFBTSxJQUFBLGlFQUF5QyxFQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsRUFBRSxDQUFDO1lBQzVGLE9BQU8sRUFBRSxDQUFDO1FBQ1osQ0FBQztRQUVELE9BQU8sSUFBQSxzQ0FBNkIsRUFBQyxN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LGVBQWUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyTSxJQUFBLGVBQUssRUFBQyx5Q0FBeUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzlJLENBQUM7SUFFRCxJQUFBLGVBQUssRUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVU7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IElTREssIE1vZGUsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4vZGVwbG95LXN0YWNrJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuaW1wb3J0IHsgcHJpbnQgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9hcHBzeW5jLW1hcHBpbmctdGVtcGxhdGVzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQ29kZUJ1aWxkUHJvamVjdENoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9jb2RlLWJ1aWxkLXByb2plY3RzJztcbmltcG9ydCB7IElDT04sIENoYW5nZUhvdHN3YXBSZXN1bHQsIEhvdHN3YXBNb2RlLCBIb3Rzd2FwcGFibGVDaGFuZ2UsIE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsIENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXMsIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UgfSBmcm9tICcuL2hvdHN3YXAvY29tbW9uJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9lY3Mtc2VydmljZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9sYW1iZGEtZnVuY3Rpb25zJztcbmltcG9ydCB7IHNraXBDaGFuZ2VGb3JTM0RlcGxveUN1c3RvbVJlc291cmNlUG9saWN5LCBpc0hvdHN3YXBwYWJsZVMzQnVja2V0RGVwbG95bWVudENoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9zMy1idWNrZXQtZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVTdGF0ZU1hY2hpbmVDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvc3RlcGZ1bmN0aW9ucy1zdGF0ZS1tYWNoaW5lcyc7XG5pbXBvcnQgeyBOZXN0ZWRTdGFja1RlbXBsYXRlcywgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MgfSBmcm9tICcuL25lc3RlZC1zdGFjay1oZWxwZXJzJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG4vLyBNdXN0IHVzZSBhIHJlcXVpcmUoKSBvdGhlcndpc2UgZXNidWlsZCBjb21wbGFpbnMgYWJvdXQgY2FsbGluZyBhIG5hbWVzcGFjZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbmNvbnN0IHBMaW1pdDogdHlwZW9mIGltcG9ydCgncC1saW1pdCcpID0gcmVxdWlyZSgncC1saW1pdCcpO1xuXG50eXBlIEhvdHN3YXBEZXRlY3RvciA9IChcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKSA9PiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+O1xuXG5jb25zdCBSRVNPVVJDRV9ERVRFQ1RPUlM6IHsgW2tleTogc3RyaW5nXTogSG90c3dhcERldGVjdG9yIH0gPSB7XG4gIC8vIExhbWJkYVxuICAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcbiAgJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcbiAgJ0FXUzo6TGFtYmRhOjpBbGlhcyc6IGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UsXG5cbiAgLy8gQXBwU3luY1xuICAnQVdTOjpBcHBTeW5jOjpSZXNvbHZlcic6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcbiAgJ0FXUzo6QXBwU3luYzo6RnVuY3Rpb25Db25maWd1cmF0aW9uJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpHcmFwaFFMU2NoZW1hJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpBcGlLZXknOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG5cbiAgJ0FXUzo6RUNTOjpUYXNrRGVmaW5pdGlvbic6IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSxcbiAgJ0FXUzo6Q29kZUJ1aWxkOjpQcm9qZWN0JzogaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlLFxuICAnQVdTOjpTdGVwRnVuY3Rpb25zOjpTdGF0ZU1hY2hpbmUnOiBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZSxcbiAgJ0N1c3RvbTo6Q0RLQnVja2V0RGVwbG95bWVudCc6IGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlLFxuICAnQVdTOjpJQU06OlBvbGljeSc6IGFzeW5jIChcbiAgICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiA9PiB7XG4gICAgLy8gSWYgdGhlIHBvbGljeSBpcyBmb3IgYSBTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsIHdlIGNhbiBpZ25vcmUgdGhlIGNoYW5nZVxuICAgIGlmIChhd2FpdCBza2lwQ2hhbmdlRm9yUzNEZXBsb3lDdXN0b21SZXNvdXJjZVBvbGljeShsb2dpY2FsSWQsIGNoYW5nZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwb3J0Tm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoY2hhbmdlLCAnVGhpcyByZXNvdXJjZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGhvdHN3YXAgZGVwbG95bWVudHMnKTtcbiAgfSxcblxuICAnQVdTOjpDREs6Ok1ldGFkYXRhJzogYXN5bmMgKCkgPT4gW10sXG59O1xuXG4vKipcbiAqIFBlcmZvcm0gYSBob3Rzd2FwIGRlcGxveW1lbnQsIHNob3J0LWNpcmN1aXRpbmcgQ2xvdWRGb3JtYXRpb24gaWYgcG9zc2libGUuXG4gKiBJZiBpdCdzIG5vdCBwb3NzaWJsZSB0byBzaG9ydC1jaXJjdWl0IHRoZSBkZXBsb3ltZW50XG4gKiAoYmVjYXVzZSB0aGUgQ0RLIFN0YWNrIGNvbnRhaW5zIGNoYW5nZXMgdGhhdCBjYW5ub3QgYmUgZGVwbG95ZWQgd2l0aG91dCBDbG91ZEZvcm1hdGlvbiksXG4gKiByZXR1cm5zIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJ5SG90c3dhcERlcGxveW1lbnQoXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgYXNzZXRQYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIGNsb3VkRm9ybWF0aW9uU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssIHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlLCBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgLy8gcmVzb2x2ZSB0aGUgZW52aXJvbm1lbnQsIHNvIHdlIGNhbiBzdWJzdGl0dXRlIHRoaW5ncyBsaWtlIEFXUzo6UmVnaW9uIGluIENGTiBleHByZXNzaW9uc1xuICBjb25zdCByZXNvbHZlZEVudiA9IGF3YWl0IHNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFja0FydGlmYWN0LmVudmlyb25tZW50KTtcbiAgLy8gY3JlYXRlIGEgbmV3IFNESyB1c2luZyB0aGUgQ0xJIGNyZWRlbnRpYWxzLCBiZWNhdXNlIHRoZSBkZWZhdWx0IG9uZSB3aWxsIG5vdCB3b3JrIGZvciBuZXctc3R5bGUgc3ludGhlc2lzIC1cbiAgLy8gaXQgYXNzdW1lcyB0aGUgYm9vdHN0cmFwIGRlcGxveSBSb2xlLCB3aGljaCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbnMgdG8gdXBkYXRlIExhbWJkYSBmdW5jdGlvbnNcbiAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KHJlc29sdmVkRW52LCBNb2RlLkZvcldyaXRpbmcpKS5zZGs7XG5cbiAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3Moc3RhY2tBcnRpZmFjdCwgc2RrKTtcblxuICBjb25zdCBldmFsdWF0ZUNmblRlbXBsYXRlID0gbmV3IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSh7XG4gICAgc3RhY2tOYW1lOiBzdGFja0FydGlmYWN0LnN0YWNrTmFtZSxcbiAgICB0ZW1wbGF0ZTogc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSxcbiAgICBwYXJhbWV0ZXJzOiBhc3NldFBhcmFtcyxcbiAgICBhY2NvdW50OiByZXNvbHZlZEVudi5hY2NvdW50LFxuICAgIHJlZ2lvbjogcmVzb2x2ZWRFbnYucmVnaW9uLFxuICAgIHBhcnRpdGlvbjogKGF3YWl0IHNkay5jdXJyZW50QWNjb3VudCgpKS5wYXJ0aXRpb24sXG4gICAgdXJsU3VmZml4OiAocmVnaW9uKSA9PiBzZGsuZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uKSxcbiAgICBzZGssXG4gICAgbmVzdGVkU3RhY2tzOiBjdXJyZW50VGVtcGxhdGUubmVzdGVkU3RhY2tzLFxuICB9KTtcblxuICBjb25zdCBzdGFja0NoYW5nZXMgPSBjZm5fZGlmZi5mdWxsRGlmZihjdXJyZW50VGVtcGxhdGUuZGVwbG95ZWRSb290VGVtcGxhdGUsIHN0YWNrQXJ0aWZhY3QudGVtcGxhdGUpO1xuICBjb25zdCB7IGhvdHN3YXBwYWJsZUNoYW5nZXMsIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMgfSA9IGF3YWl0IGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICAgIHN0YWNrQ2hhbmdlcywgZXZhbHVhdGVDZm5UZW1wbGF0ZSwgc2RrLCBjdXJyZW50VGVtcGxhdGUubmVzdGVkU3RhY2tzLCBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICk7XG5cbiAgbG9nTm9uSG90c3dhcHBhYmxlQ2hhbmdlcyhub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLCBob3Rzd2FwTW9kZSk7XG5cbiAgLy8gcHJlc2VydmUgY2xhc3NpYyBob3Rzd2FwIGJlaGF2aW9yXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gSG90c3dhcE1vZGUuRkFMTF9CQUNLKSB7XG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBhcHBseSB0aGUgc2hvcnQtY2lyY3VpdGFibGUgY2hhbmdlc1xuICBhd2FpdCBhcHBseUFsbEhvdHN3YXBwYWJsZUNoYW5nZXMoc2RrLCBob3Rzd2FwcGFibGVDaGFuZ2VzKTtcblxuICByZXR1cm4geyBub09wOiBob3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCwgc3RhY2tBcm46IGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tJZCwgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzIH07XG59XG5cbi8qKlxuICogQ2xhc3NpZmllcyBhbGwgY2hhbmdlcyB0byBhbGwgcmVzb3VyY2VzIGFzIGVpdGhlciBob3Rzd2FwcGFibGUgb3Igbm90LlxuICogTWV0YWRhdGEgY2hhbmdlcyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgbGlzdCBvZiAobm9uKWhvdHN3YXBwYWJsZSByZXNvdXJjZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICBzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZixcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IElTREssXG4gIG5lc3RlZFN0YWNrTmFtZXM6IHsgW25lc3RlZFN0YWNrTmFtZTogc3RyaW5nXTogTmVzdGVkU3RhY2tUZW1wbGF0ZXMgfSxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pOiBQcm9taXNlPENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXM+IHtcbiAgY29uc3QgcmVzb3VyY2VEaWZmZXJlbmNlcyA9IGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXMpO1xuXG4gIGNvbnN0IHByb21pc2VzOiBBcnJheTwoKSA9PiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+PiA9IFtdO1xuICBjb25zdCBob3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8SG90c3dhcHBhYmxlQ2hhbmdlPigpO1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8Tm9uSG90c3dhcHBhYmxlQ2hhbmdlPigpO1xuICBmb3IgKGNvbnN0IGxvZ2ljYWxJZCBvZiBPYmplY3Qua2V5cyhzdGFja0NoYW5nZXMub3V0cHV0cy5jaGFuZ2VzKSkge1xuICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZWFzb246ICdvdXRwdXQgd2FzIGNoYW5nZWQnLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlc291cmNlVHlwZTogJ1N0YWNrIE91dHB1dCcsXG4gICAgfSk7XG4gIH1cbiAgLy8gZ2F0aGVyIHRoZSByZXN1bHRzIG9mIHRoZSBkZXRlY3RvciBmdW5jdGlvbnNcbiAgZm9yIChjb25zdCBbbG9naWNhbElkLCBjaGFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKHJlc291cmNlRGlmZmVyZW5jZXMpKSB7XG4gICAgaWYgKGNoYW5nZS5uZXdWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyAmJiBjaGFuZ2Uub2xkVmFsdWU/LlR5cGUgPT09ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycpIHtcbiAgICAgIGNvbnN0IG5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcyA9IGF3YWl0IGZpbmROZXN0ZWRIb3Rzd2FwcGFibGVDaGFuZ2VzKFxuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIGNoYW5nZSxcbiAgICAgICAgbmVzdGVkU3RhY2tOYW1lcyxcbiAgICAgICAgZXZhbHVhdGVDZm5UZW1wbGF0ZSxcbiAgICAgICAgc2RrLFxuICAgICAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICAgICApO1xuICAgICAgaG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goLi4ubmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzLmhvdHN3YXBwYWJsZUNoYW5nZXMpO1xuICAgICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goLi4ubmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzLm5vbkhvdHN3YXBwYWJsZUNoYW5nZXMpO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgPSBpc0NhbmRpZGF0ZUZvckhvdHN3YXBwaW5nKGNoYW5nZSwgbG9naWNhbElkKTtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHJ1biB0aGlzIHRocm91Z2ggdGhlIGRldGVjdG9yIGZ1bmN0aW9ucywgd2UgY2FuIGFscmVhZHkganVkZ2UgdGhpc1xuICAgIGlmICgnaG90c3dhcHBhYmxlJyBpbiBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpIHtcbiAgICAgIGlmICghaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLmhvdHN3YXBwYWJsZSkge1xuICAgICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZVR5cGU6IHN0cmluZyA9IGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZS5uZXdWYWx1ZS5UeXBlO1xuICAgIGlmIChyZXNvdXJjZVR5cGUgaW4gUkVTT1VSQ0VfREVURUNUT1JTKSB7XG4gICAgICAvLyBydW4gZGV0ZWN0b3IgZnVuY3Rpb25zIGxhemlseSB0byBwcmV2ZW50IHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICAgIHByb21pc2VzLnB1c2goKCkgPT4gUkVTT1VSQ0VfREVURUNUT1JTW3Jlc291cmNlVHlwZV0obG9naWNhbElkLCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2Uobm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIHVuZGVmaW5lZCwgJ1RoaXMgcmVzb3VyY2UgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBob3Rzd2FwIGRlcGxveW1lbnRzJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBhbGwgZGV0ZWN0b3IgcmVzdWx0c1xuICBjb25zdCBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0czogQXJyYXk8Q2hhbmdlSG90c3dhcFJlc3VsdD4gPSBbXTtcbiAgZm9yIChjb25zdCBkZXRlY3RvclJlc3VsdFByb21pc2VzIG9mIHByb21pc2VzKSB7XG4gICAgLy8gQ29uc3RhbnQgc2V0IG9mIHByb21pc2VzIHBlciByZXNvdXJjZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgIGNvbnN0IGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXdhaXQgZGV0ZWN0b3JSZXN1bHRQcm9taXNlcygpKTtcbiAgICBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0cy5wdXNoKGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcmVzb3VyY2VEZXRlY3Rpb25SZXN1bHRzIG9mIGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eVJlc3VsdCBvZiByZXNvdXJjZURldGVjdGlvblJlc3VsdHMpIHtcbiAgICAgIHByb3BlcnR5UmVzdWx0LmhvdHN3YXBwYWJsZSA/XG4gICAgICAgIGhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHByb3BlcnR5UmVzdWx0KSA6XG4gICAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKHByb3BlcnR5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhvdHN3YXBwYWJsZUNoYW5nZXM6IGhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMsXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgY2hhbmdlcyB0byByZXNvdXJjZXMgaW4gdGhlIGdpdmVuIFN0YWNrLlxuICpcbiAqIEBwYXJhbSBzdGFja0NoYW5nZXMgdGhlIGNvbGxlY3Rpb24gb2YgYWxsIGNoYW5nZXMgdG8gYSBnaXZlbiBTdGFja1xuICovXG5mdW5jdGlvbiBnZXRTdGFja1Jlc291cmNlRGlmZmVyZW5jZXMoc3RhY2tDaGFuZ2VzOiBjZm5fZGlmZi5UZW1wbGF0ZURpZmYpOiB7IFtsb2dpY2FsSWQ6IHN0cmluZ106IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB9IHtcbiAgLy8gd2UgbmVlZCB0byBjb2xsYXBzZSBsb2dpY2FsIElEIHJlbmFtZSBjaGFuZ2VzIGludG8gb25lIGNoYW5nZSxcbiAgLy8gYXMgdGhleSBhcmUgcmVwcmVzZW50ZWQgaW4gc3RhY2tDaGFuZ2VzIGFzIGEgcGFpciBvZiB0d28gY2hhbmdlczogb25lIGFkZGl0aW9uIGFuZCBvbmUgcmVtb3ZhbFxuICBjb25zdCBhbGxSZXNvdXJjZUNoYW5nZXM6IHsgW2xvZ0lkOiBzdHJpbmddOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UgfSA9IHN0YWNrQ2hhbmdlcy5yZXNvdXJjZXMuY2hhbmdlcztcbiAgY29uc3QgYWxsUmVtb3ZhbENoYW5nZXMgPSBmaWx0ZXJEaWN0KGFsbFJlc291cmNlQ2hhbmdlcywgcmVzQ2hhbmdlID0+IHJlc0NoYW5nZS5pc1JlbW92YWwpO1xuICBjb25zdCBhbGxOb25SZW1vdmFsQ2hhbmdlcyA9IGZpbHRlckRpY3QoYWxsUmVzb3VyY2VDaGFuZ2VzLCByZXNDaGFuZ2UgPT4gIXJlc0NoYW5nZS5pc1JlbW92YWwpO1xuICBmb3IgKGNvbnN0IFtsb2dJZCwgbm9uUmVtb3ZhbENoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsTm9uUmVtb3ZhbENoYW5nZXMpKSB7XG4gICAgaWYgKG5vblJlbW92YWxDaGFuZ2UuaXNBZGRpdGlvbikge1xuICAgICAgY29uc3QgYWRkQ2hhbmdlID0gbm9uUmVtb3ZhbENoYW5nZTtcbiAgICAgIC8vIHNlYXJjaCBmb3IgYW4gaWRlbnRpY2FsIHJlbW92YWwgY2hhbmdlXG4gICAgICBjb25zdCBpZGVudGljYWxSZW1vdmFsQ2hhbmdlID0gT2JqZWN0LmVudHJpZXMoYWxsUmVtb3ZhbENoYW5nZXMpLmZpbmQoKFtfLCByZW1DaGFuZ2VdKSA9PiB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzQXJlRm9yU2FtZVJlc291cmNlKHJlbUNoYW5nZSwgYWRkQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gaWYgd2UgZm91bmQgb25lLCB0aGVuIHRoaXMgbWVhbnMgdGhpcyBpcyBhIHJlbmFtZSBjaGFuZ2VcbiAgICAgIGlmIChpZGVudGljYWxSZW1vdmFsQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IFtyZW1vdmVkTG9nSWQsIHJlbW92ZWRSZXNvdXJjZUNoYW5nZV0gPSBpZGVudGljYWxSZW1vdmFsQ2hhbmdlO1xuICAgICAgICBhbGxOb25SZW1vdmFsQ2hhbmdlc1tsb2dJZF0gPSBtYWtlUmVuYW1lRGlmZmVyZW5jZShyZW1vdmVkUmVzb3VyY2VDaGFuZ2UsIGFkZENoYW5nZSk7XG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgcmVtb3ZhbCBjaGFuZ2UgdGhhdCBmb3JtcyB0aGUgcmVuYW1lIHBhaXJcbiAgICAgICAgZGVsZXRlIGFsbFJlbW92YWxDaGFuZ2VzW3JlbW92ZWRMb2dJZF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgYXJlIGFsbCBvZiB0aGUgcmVtYWluaW5nIHJlbW92YWwgY2hhbmdlcyxcbiAgLy8gcGx1cyBhbGwgb2YgdGhlIG5vbi1yZW1vdmFsIGNoYW5nZXNcbiAgLy8gKHdlIHNhdmVkIHRoZSByZW5hbWUgY2hhbmdlcyBpbiB0aGF0IG9iamVjdCBhbHJlYWR5KVxuICByZXR1cm4ge1xuICAgIC4uLmFsbFJlbW92YWxDaGFuZ2VzLFxuICAgIC4uLmFsbE5vblJlbW92YWxDaGFuZ2VzLFxuICB9O1xufVxuXG4vKiogRmlsdGVycyBhbiBvYmplY3Qgd2l0aCBzdHJpbmcga2V5cyBiYXNlZCBvbiB3aGV0aGVyIHRoZSBjYWxsYmFjayByZXR1cm5zICd0cnVlJyBmb3IgdGhlIGdpdmVuIHZhbHVlIGluIHRoZSBvYmplY3QuICovXG5mdW5jdGlvbiBmaWx0ZXJEaWN0PFQ+KGRpY3Q6IHsgW2tleTogc3RyaW5nXTogVCB9LCBmdW5jOiAodDogVCkgPT4gYm9vbGVhbik6IHsgW2tleTogc3RyaW5nXTogVCB9IHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRpY3QpLnJlZHVjZSgoYWNjLCBba2V5LCB0XSkgPT4ge1xuICAgIGlmIChmdW5jKHQpKSB7XG4gICAgICBhY2Nba2V5XSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIHsgW2tleTogc3RyaW5nXTogVCB9KTtcbn1cblxuLyoqIEZpbmRzIGFueSBob3Rzd2FwcGFibGUgY2hhbmdlcyBpbiBhbGwgbmVzdGVkIHN0YWNrcy4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmROZXN0ZWRIb3Rzd2FwcGFibGVDaGFuZ2VzKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIG5lc3RlZFN0YWNrVGVtcGxhdGVzOiB7IFtuZXN0ZWRTdGFja05hbWU6IHN0cmluZ106IE5lc3RlZFN0YWNrVGVtcGxhdGVzIH0sXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgc2RrOiBJU0RLLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8Q2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcz4ge1xuICBjb25zdCBuZXN0ZWRTdGFjayA9IG5lc3RlZFN0YWNrVGVtcGxhdGVzW2xvZ2ljYWxJZF07XG4gIGlmICghbmVzdGVkU3RhY2sucGh5c2ljYWxOYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZUNoYW5nZXM6IFtdLFxuICAgICAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogW3tcbiAgICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgICAgbG9naWNhbElkLFxuICAgICAgICByZWFzb246IGBwaHlzaWNhbCBuYW1lIGZvciBBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjayAnJHtsb2dpY2FsSWR9JyBjb3VsZCBub3QgYmUgZm91bmQgaW4gQ2xvdWRGb3JtYXRpb24sIHNvIHRoaXMgaXMgYSBuZXdseSBjcmVhdGVkIG5lc3RlZCBzdGFjayBhbmQgY2Fubm90IGJlIGhvdHN3YXBwZWRgLFxuICAgICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgICByZXNvdXJjZVR5cGU6ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycsXG4gICAgICB9XSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGVOZXN0ZWRDZm5UZW1wbGF0ZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuY3JlYXRlTmVzdGVkRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKFxuICAgIG5lc3RlZFN0YWNrLnBoeXNpY2FsTmFtZSwgbmVzdGVkU3RhY2suZ2VuZXJhdGVkVGVtcGxhdGUsIGNoYW5nZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uUGFyYW1ldGVycyxcbiAgKTtcblxuICBjb25zdCBuZXN0ZWREaWZmID0gY2ZuX2RpZmYuZnVsbERpZmYoXG4gICAgbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXS5kZXBsb3llZFRlbXBsYXRlLCBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdLmdlbmVyYXRlZFRlbXBsYXRlLFxuICApO1xuXG4gIHJldHVybiBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgICBuZXN0ZWREaWZmLFxuICAgIGV2YWx1YXRlTmVzdGVkQ2ZuVGVtcGxhdGUsXG4gICAgc2RrLFxuICAgIG5lc3RlZFN0YWNrVGVtcGxhdGVzW2xvZ2ljYWxJZF0ubmVzdGVkU3RhY2tUZW1wbGF0ZXMsXG4gICAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzKTtcbn1cblxuLyoqIFJldHVybnMgJ3RydWUnIGlmIGEgcGFpciBvZiBjaGFuZ2VzIGlzIGZvciB0aGUgc2FtZSByZXNvdXJjZS4gKi9cbmZ1bmN0aW9uIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2Uob2xkQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsIG5ld0NoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlKTogYm9vbGVhbiB7XG4gIHJldHVybiBvbGRDaGFuZ2Uub2xkUmVzb3VyY2VUeXBlID09PSBuZXdDaGFuZ2UubmV3UmVzb3VyY2VUeXBlICYmXG4gICAgLy8gdGhpcyBpc24ndCBncmVhdCwgYnV0IEkgZG9uJ3Qgd2FudCB0byBicmluZyBpbiBzb21ldGhpbmcgbGlrZSB1bmRlcnNjb3JlIGp1c3QgZm9yIHRoaXMgY29tcGFyaXNvblxuICAgIEpTT04uc3RyaW5naWZ5KG9sZENoYW5nZS5vbGRQcm9wZXJ0aWVzKSA9PT0gSlNPTi5zdHJpbmdpZnkobmV3Q2hhbmdlLm5ld1Byb3BlcnRpZXMpO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVuYW1lRGlmZmVyZW5jZShcbiAgcmVtQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIGFkZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuKTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIHtcbiAgcmV0dXJuIG5ldyBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UoXG4gICAgLy8gd2UgaGF2ZSB0byBmaWxsIGluIHRoZSBvbGQgdmFsdWUsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoaXMgd2lsbCBiZSBjbGFzc2lmaWVkIGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VcbiAgICByZW1DaGFuZ2Uub2xkVmFsdWUsXG4gICAgYWRkQ2hhbmdlLm5ld1ZhbHVlLFxuICAgIHtcbiAgICAgIHJlc291cmNlVHlwZToge1xuICAgICAgICBvbGRUeXBlOiByZW1DaGFuZ2Uub2xkUmVzb3VyY2VUeXBlLFxuICAgICAgICBuZXdUeXBlOiBhZGRDaGFuZ2UubmV3UmVzb3VyY2VUeXBlLFxuICAgICAgfSxcbiAgICAgIHByb3BlcnR5RGlmZnM6IChhZGRDaGFuZ2UgYXMgYW55KS5wcm9wZXJ0eURpZmZzLFxuICAgICAgb3RoZXJEaWZmczogKGFkZENoYW5nZSBhcyBhbnkpLm90aGVyRGlmZnMsXG4gICAgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZWAgaWYgdGhlIGNoYW5nZSBpcyBob3Rzd2FwcGFibGVcbiAqIFJldHVybnMgYW4gZW1wdHkgYEhvdHN3YXBwYWJsZUNoYW5nZWAgaWYgdGhlIGNoYW5nZSBpcyB0byBDREs6Ok1ldGFkYXRhXG4gKiBSZXR1cm5zIGEgYE5vbkhvdHN3YXBwYWJsZUNoYW5nZWAgaWYgdGhlIGNoYW5nZSBpcyBub3QgaG90c3dhcHBhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzQ2FuZGlkYXRlRm9ySG90c3dhcHBpbmcoXG4gIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLCBsb2dpY2FsSWQ6IHN0cmluZyxcbik6IEhvdHN3YXBwYWJsZUNoYW5nZSB8IE5vbkhvdHN3YXBwYWJsZUNoYW5nZSB8IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB7XG4gIC8vIGEgcmVzb3VyY2UgaGFzIGJlZW4gcmVtb3ZlZCBPUiBhIHJlc291cmNlIGhhcyBiZWVuIGFkZGVkOyB3ZSBjYW4ndCBzaG9ydC1jaXJjdWl0IHRoYXQgY2hhbmdlXG4gIGlmICghY2hhbmdlLm9sZFZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZSEuVHlwZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZWFzb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyB3YXMgY3JlYXRlZCBieSB0aGlzIGRlcGxveW1lbnRgLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoIWNoYW5nZS5uZXdWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2Uub2xkVmFsdWUhLlR5cGUsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVhc29uOiBgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgd2FzIGRlc3Ryb3llZCBieSB0aGlzIGRlcGxveW1lbnRgLFxuICAgIH07XG4gIH1cblxuICAvLyBhIHJlc291cmNlIGhhcyBoYWQgaXRzIHR5cGUgY2hhbmdlZFxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlPy5UeXBlICE9PSBjaGFuZ2Uub2xkVmFsdWU/LlR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlPy5UeXBlLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlYXNvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIGhhZCBpdHMgdHlwZSBjaGFuZ2VkIGZyb20gJyR7Y2hhbmdlLm9sZFZhbHVlPy5UeXBlfScgdG8gJyR7Y2hhbmdlLm5ld1ZhbHVlPy5UeXBlfSdgLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvZ2ljYWxJZCxcbiAgICBvbGRWYWx1ZTogY2hhbmdlLm9sZFZhbHVlLFxuICAgIG5ld1ZhbHVlOiBjaGFuZ2UubmV3VmFsdWUsXG4gICAgcHJvcGVydHlVcGRhdGVzOiBjaGFuZ2UucHJvcGVydHlVcGRhdGVzLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhcHBseUFsbEhvdHN3YXBwYWJsZUNoYW5nZXMoc2RrOiBJU0RLLCBob3Rzd2FwcGFibGVDaGFuZ2VzOiBIb3Rzd2FwcGFibGVDaGFuZ2VbXSk6IFByb21pc2U8dm9pZFtdPiB7XG4gIGlmIChob3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICBwcmludChgXFxuJHtJQ09OfSBob3Rzd2FwcGluZyByZXNvdXJjZXM6YCk7XG4gIH1cbiAgY29uc3QgbGltaXQgPSBwTGltaXQoMTApO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgcmV0dXJuIFByb21pc2UuYWxsKGhvdHN3YXBwYWJsZUNoYW5nZXMubWFwKGhvdHN3YXBPcGVyYXRpb24gPT4gbGltaXQoKCkgPT4ge1xuICAgIHJldHVybiBhcHBseUhvdHN3YXBwYWJsZUNoYW5nZShzZGssIGhvdHN3YXBPcGVyYXRpb24pO1xuICB9KSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhcHBseUhvdHN3YXBwYWJsZUNoYW5nZShzZGs6IElTREssIGhvdHN3YXBPcGVyYXRpb246IEhvdHN3YXBwYWJsZUNoYW5nZSk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBub3RlIHRoZSB0eXBlIG9mIHNlcnZpY2UgdGhhdCB3YXMgc3VjY2Vzc2Z1bGx5IGhvdHN3YXBwZWQgaW4gdGhlIFVzZXItQWdlbnRcbiAgY29uc3QgY3VzdG9tVXNlckFnZW50ID0gYGNkay1ob3Rzd2FwL3N1Y2Nlc3MtJHtob3Rzd2FwT3BlcmF0aW9uLnNlcnZpY2V9YDtcbiAgc2RrLmFwcGVuZEN1c3RvbVVzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBob3Rzd2FwT3BlcmF0aW9uLnJlc291cmNlTmFtZXMpIHtcbiAgICBwcmludChgICAgJHtJQ09OfSAlc2AsIGNoYWxrLmJvbGQobmFtZSkpO1xuICB9XG5cbiAgLy8gaWYgdGhlIFNESyBjYWxsIGZhaWxzLCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBieSB0aGUgU0RLXG4gIC8vIGFuZCB3aWxsIHByZXZlbnQgdGhlIGdyZWVuICdob3Rzd2FwcGVkIScgdGV4dCBmcm9tIGJlaW5nIGRpc3BsYXllZFxuICBhd2FpdCBob3Rzd2FwT3BlcmF0aW9uLmFwcGx5KHNkayk7XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIGhvdHN3YXBPcGVyYXRpb24ucmVzb3VyY2VOYW1lcykge1xuICAgIHByaW50KGAke0lDT059ICVzICVzYCwgY2hhbGsuYm9sZChuYW1lKSwgY2hhbGsuZ3JlZW4oJ2hvdHN3YXBwZWQhJykpO1xuICB9XG5cbiAgc2RrLnJlbW92ZUN1c3RvbVVzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xufVxuXG5mdW5jdGlvbiBsb2dOb25Ib3Rzd2FwcGFibGVDaGFuZ2VzKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IE5vbkhvdHN3YXBwYWJsZUNoYW5nZVtdLCBob3Rzd2FwTW9kZTogSG90c3dhcE1vZGUpOiB2b2lkIHtcbiAgaWYgKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBFS1MgU2VydmljZXMgY2FuIGhhdmUgYSB0YXNrIGRlZmluaXRpb24gdGhhdCBkb2Vzbid0IHJlZmVyIHRvIHRoZSB0YXNrIGRlZmluaXRpb24gYmVpbmcgdXBkYXRlZC5cbiAgICogV2UgaGF2ZSB0byBsb2cgdGhpcyBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlIHRvIHRoZSB0YXNrIGRlZmluaXRpb24sIGJ1dCB3aGVuIHdlIGRvLFxuICAgKiB3ZSB3aW5kIHVwIGhvdHN3YXBwaW5nIHRoZSB0YXNrIGRlZmluaXRpb24gYW5kIGxvZ2dpbmcgaXQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZS5cbiAgICpcbiAgICogVGhpcyBsb2dpYyBwcmV2ZW50cyB1cyBmcm9tIGxvZ2dpbmcgdGhhdCBjaGFuZ2UgYXMgbm9uLWhvdHN3YXBwYWJsZSB3aGVuIHdlIGhvdHN3YXAgaXQuXG4gICAqL1xuICBpZiAoaG90c3dhcE1vZGUgPT09IEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWSkge1xuICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMgPSBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmZpbHRlcigoY2hhbmdlKSA9PiBjaGFuZ2UuaG90c3dhcE9ubHlWaXNpYmxlID09PSB0cnVlKTtcblxuICAgIGlmIChub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaG90c3dhcE1vZGUgPT09IEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWSkge1xuICAgIHByaW50KCdcXG4lcyAlcycsIGNoYWxrLnJlZCgn4pqg77iPJyksIGNoYWxrLnJlZCgnVGhlIGZvbGxvd2luZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgd2VyZSBmb3VuZC4gVG8gcmVjb25jaWxlIHRoZXNlIHVzaW5nIENsb3VkRm9ybWF0aW9uLCBzcGVjaWZ5IC0taG90c3dhcC1mYWxsYmFjaycpKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludCgnXFxuJXMgJXMnLCBjaGFsay5yZWQoJ+KaoO+4jycpLCBjaGFsay5yZWQoJ1RoZSBmb2xsb3dpbmcgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VzIHdlcmUgZm91bmQ6JykpO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGFuZ2Ugb2Ygbm9uSG90c3dhcHBhYmxlQ2hhbmdlcykge1xuICAgIGNoYW5nZS5yZWplY3RlZENoYW5nZXMubGVuZ3RoID4gMCA/XG4gICAgICBwcmludCgnICAgIGxvZ2ljYWxJRDogJXMsIHR5cGU6ICVzLCByZWplY3RlZCBjaGFuZ2VzOiAlcywgcmVhc29uOiAlcycsIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksIGNoYWxrLmJvbGQoY2hhbmdlLnJlamVjdGVkQ2hhbmdlcyksIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSkgOlxuICAgICAgcHJpbnQoJyAgICBsb2dpY2FsSUQ6ICVzLCB0eXBlOiAlcywgcmVhc29uOiAlcycsIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSk7XG4gIH1cblxuICBwcmludCgnJyk7IC8vIG5ld2xpbmVcbn1cbiJdfQ==