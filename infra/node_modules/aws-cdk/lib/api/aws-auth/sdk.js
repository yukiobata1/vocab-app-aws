"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SDK_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUnrecoverableAwsError = exports.SDK = void 0;
const AWS = require("aws-sdk");
const _env_1 = require("./_env");
const account_cache_1 = require("./account-cache");
const cached_1 = require("./cached");
const tracing_1 = require("../../util/tracing");
// We need to map regions to domain suffixes, and the SDK already has a function to do this.
// It's not part of the public API, but it's also unlikely to go away.
//
// Reuse that function, and add a safety check, so we don't accidentally break if they ever
// refactor that away.
/* eslint-disable @typescript-eslint/no-require-imports */
const regionUtil = require('aws-sdk/lib/region_config');
require('aws-sdk/lib/maintenance_mode_message').suppress = true;
/* eslint-enable @typescript-eslint/no-require-imports */
if (!regionUtil.getEndpointSuffix) {
    throw new Error('This version of AWS SDK for JS does not have the \'getEndpointSuffix\' function!');
}
/**
 * Base functionality of SDK without credential fetching
 */
let SDK = SDK_1 = class SDK {
    constructor(_credentials, region, httpOptions = {}, sdkOptions = {}) {
        this._credentials = _credentials;
        this.sdkOptions = sdkOptions;
        /**
         * Default retry options for SDK clients.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        /**
         * The more generous retry policy for CloudFormation, which has a 1 TPM limit on certain APIs,
         * which are abundantly used for deployment tracking, ...
         *
         * So we're allowing way more retries, but waiting a bit more.
         */
        this.cloudFormationRetryOptions = { maxRetries: 10, retryDelayOptions: { base: 1000 } };
        /**
         * STS is used to check credential validity, don't do too many retries.
         */
        this.stsRetryOptions = { maxRetries: 3, retryDelayOptions: { base: 100 } };
        /**
         * Whether we have proof that the credentials have not expired
         *
         * We need to do some manual plumbing around this because the JS SDKv2 treats `ExpiredToken`
         * as retriable and we have hefty retries on CFN calls making the CLI hang for a good 15 minutes
         * if the credentials have expired.
         */
        this._credentialsValidated = false;
        this.config = {
            ...httpOptions,
            ...this.retryOptions,
            credentials: _credentials,
            region,
            logger: { log: (...messages) => messages.forEach(m => (0, _env_1.trace)('%s', m)) },
        };
        this.currentRegion = region;
    }
    appendCustomUserAgent(userAgentData) {
        if (!userAgentData) {
            return;
        }
        const currentCustomUserAgent = this.config.customUserAgent;
        this.config.customUserAgent = currentCustomUserAgent
            ? `${currentCustomUserAgent} ${userAgentData}`
            : userAgentData;
    }
    removeCustomUserAgent(userAgentData) {
        this.config.customUserAgent = this.config.customUserAgent?.replace(userAgentData, '');
    }
    lambda() {
        return this.wrapServiceErrorHandling(new AWS.Lambda(this.config));
    }
    cloudFormation() {
        return this.wrapServiceErrorHandling(new AWS.CloudFormation({
            ...this.config,
            ...this.cloudFormationRetryOptions,
        }));
    }
    ec2() {
        return this.wrapServiceErrorHandling(new AWS.EC2(this.config));
    }
    iam() {
        return this.wrapServiceErrorHandling(new AWS.IAM(this.config));
    }
    ssm() {
        return this.wrapServiceErrorHandling(new AWS.SSM(this.config));
    }
    s3({ needsMd5Checksums: apiRequiresMd5Checksum = false, } = {}) {
        const config = { ...this.config };
        if (!apiRequiresMd5Checksum) {
            // In FIPS enabled environments, the MD5 algorithm is not available for use in crypto module.
            // However by default the S3 client is using an MD5 checksum for content integrity checking.
            // While this usage is technically allowed in FIPS (MD5 is only prohibited for cryptographic use),
            // in practice it is just easier to use an allowed checksum mechanism.
            // We are disabling the S3 content checksums, and are re-enabling the regular SigV4 body signing.
            // SigV4 uses SHA256 for their content checksum. This configuration matches the default behavior
            // of the AWS SDKv3 and is a safe choice for all users, except in the above APIs.
            config.s3DisableBodySigning = false;
            config.computeChecksums = false;
        }
        return this.wrapServiceErrorHandling(new AWS.S3(config));
    }
    route53() {
        return this.wrapServiceErrorHandling(new AWS.Route53(this.config));
    }
    ecr() {
        return this.wrapServiceErrorHandling(new AWS.ECR(this.config));
    }
    ecs() {
        return this.wrapServiceErrorHandling(new AWS.ECS(this.config));
    }
    elbv2() {
        return this.wrapServiceErrorHandling(new AWS.ELBv2(this.config));
    }
    secretsManager() {
        return this.wrapServiceErrorHandling(new AWS.SecretsManager(this.config));
    }
    kms() {
        return this.wrapServiceErrorHandling(new AWS.KMS(this.config));
    }
    stepFunctions() {
        return this.wrapServiceErrorHandling(new AWS.StepFunctions(this.config));
    }
    codeBuild() {
        return this.wrapServiceErrorHandling(new AWS.CodeBuild(this.config));
    }
    cloudWatchLogs() {
        return this.wrapServiceErrorHandling(new AWS.CloudWatchLogs(this.config));
    }
    appsync() {
        return this.wrapServiceErrorHandling(new AWS.AppSync(this.config));
    }
    async currentAccount() {
        // Get/refresh if necessary before we can access `accessKeyId`
        await this.forceCredentialRetrieval();
        return (0, cached_1.cached)(this, CURRENT_ACCOUNT_KEY, () => SDK_1.accountCache.fetch(this._credentials.accessKeyId, async () => {
            // if we don't have one, resolve from STS and store in cache.
            (0, _env_1.debug)('Looking up default account ID from STS');
            const result = await new AWS.STS({ ...this.config, ...this.stsRetryOptions }).getCallerIdentity().promise();
            const accountId = result.Account;
            const partition = result.Arn.split(':')[1];
            if (!accountId) {
                throw new Error('STS didn\'t return an account ID');
            }
            (0, _env_1.debug)('Default account ID:', accountId);
            // Save another STS call later if this one already succeeded
            this._credentialsValidated = true;
            return { accountId, partition };
        }));
    }
    /**
     * Return the current credentials
     *
     * Don't use -- only used to write tests around assuming roles.
     */
    async currentCredentials() {
        await this.forceCredentialRetrieval();
        return this._credentials;
    }
    /**
     * Force retrieval of the current credentials
     *
     * Relevant if the current credentials are AssumeRole credentials -- do the actual
     * lookup, and translate any error into a useful error message (taking into
     * account credential provenance).
     */
    async forceCredentialRetrieval() {
        try {
            await this._credentials.getPromise();
        }
        catch (e) {
            if (isUnrecoverableAwsError(e)) {
                throw e;
            }
            // Only reason this would fail is if it was an AssumRole. Otherwise,
            // reading from an INI file or reading env variables is unlikely to fail.
            (0, _env_1.debug)(`Assuming role failed: ${e.message}`);
            throw new Error([
                'Could not assume role in target account',
                ...this.sdkOptions.assumeRoleCredentialsSourceDescription
                    ? [`using ${this.sdkOptions.assumeRoleCredentialsSourceDescription}`]
                    : [],
                e.message,
                '. Please make sure that this role exists in the account. If it doesn\'t exist, (re)-bootstrap the environment ' +
                    'with the right \'--trust\', using the latest version of the CDK CLI.',
            ].join(' '));
        }
    }
    /**
     * Make sure the the current credentials are not expired
     */
    async validateCredentials() {
        if (this._credentialsValidated) {
            return;
        }
        await new AWS.STS({ ...this.config, ...this.stsRetryOptions }).getCallerIdentity().promise();
        this._credentialsValidated = true;
    }
    getEndpointSuffix(region) {
        return regionUtil.getEndpointSuffix(region);
    }
    /**
     * Return a wrapping object for the underlying service object
     *
     * Responds to failures in the underlying service calls, in two different
     * ways:
     *
     * - When errors are encountered, log the failing call and the error that
     *   it triggered (at debug level). This is necessary because the lack of
     *   stack traces in NodeJS otherwise makes it very hard to suss out where
     *   a certain AWS error occurred.
     * - The JS SDK has a funny business of wrapping any credential-based error
     *   in a super-generic (and in our case wrong) exception. If we then use a
     *   'ChainableTemporaryCredentials' and the target role doesn't exist,
     *   the error message that shows up by default is super misleading
     *   (https://github.com/aws/aws-sdk-js/issues/3272). We can fix this because
     *   the exception contains the "inner exception", so we unwrap and throw
     *   the correct error ("cannot assume role").
     *
     * The wrapping business below is slightly more complicated than you'd think
     * because we must hook into the `promise()` method of the object that's being
     * returned from the methods of the object that we wrap, so there's two
     * levels of wrapping going on, and also some exceptions to the wrapping magic.
     */
    wrapServiceErrorHandling(serviceObject) {
        const classObject = serviceObject.constructor.prototype;
        const self = this;
        return new Proxy(serviceObject, {
            get(obj, prop) {
                const real = obj[prop];
                // Things we don't want to intercept:
                // - Anything that's not a function.
                // - 'constructor', s3.upload() will use this to do some magic and we need the underlying constructor.
                // - Any method that's not on the service class (do not intercept 'makeRequest' and other helpers).
                if (prop === 'constructor' || !classObject.hasOwnProperty(prop) || !isFunction(real)) {
                    return real;
                }
                // NOTE: This must be a function() and not an () => {
                // because I need 'this' to be dynamically bound and not statically bound.
                // If your linter complains don't listen to it!
                return function () {
                    // Call the underlying function. If it returns an object with a promise()
                    // method on it, wrap that 'promise' method.
                    const args = [].slice.call(arguments, 0);
                    const response = real.apply(this, args);
                    // Don't intercept unless the return value is an object with a '.promise()' method.
                    if (typeof response !== 'object' || !response) {
                        return response;
                    }
                    if (!('promise' in response)) {
                        return response;
                    }
                    // Return an object with the promise method replaced with a wrapper which will
                    // do additional things to errors.
                    return Object.assign(Object.create(response), {
                        promise() {
                            return response.promise().catch((e) => {
                                e = self.makeDetailedException(e);
                                (0, _env_1.debug)(`Call failed: ${prop}(${JSON.stringify(args[0])}) => ${e.message} (code=${e.code})`);
                                return Promise.reject(e); // Re-'throw' the new error
                            });
                        },
                    });
                };
            },
        });
    }
    /**
     * Extract a more detailed error out of a generic error if we can
     *
     * If this is an error about Assuming Roles, add in the context showing the
     * chain of credentials we used to try to assume the role.
     */
    makeDetailedException(e) {
        // This is the super-generic "something's wrong" error that the JS SDK wraps other errors in.
        // https://github.com/aws/aws-sdk-js/blob/f0ac2e53457c7512883d0677013eacaad6cd8a19/lib/event_listeners.js#L84
        if (typeof e.message === 'string' && e.message.startsWith('Missing credentials in config')) {
            const original = e.originalError;
            if (original) {
                // When the SDK does a 'util.copy', they lose the Error-ness of the inner error
                // (they copy the Error's properties into a plain object) so make it an Error object again.
                e = Object.assign(new Error(), original);
            }
        }
        // At this point, the error might still be a generic "ChainableTemporaryCredentials failed"
        // error which wraps the REAL error (AssumeRole failed). We're going to replace the error
        // message with one that's more likely to help users, and tell them the most probable
        // fix (bootstrapping). The underlying service call failure will be appended below.
        if (e.message === 'Could not load credentials from ChainableTemporaryCredentials') {
            e.message = [
                'Could not assume role in target account',
                ...this.sdkOptions.assumeRoleCredentialsSourceDescription
                    ? [`using ${this.sdkOptions.assumeRoleCredentialsSourceDescription}`]
                    : [],
                '(did you bootstrap the environment with the right \'--trust\'s?)',
            ].join(' ');
        }
        // Replace the message on this error with a concatenation of all inner error messages.
        // Must more clear what's going on that way.
        e.message = allChainedExceptionMessages(e);
        return e;
    }
};
exports.SDK = SDK;
SDK.accountCache = new account_cache_1.AccountAccessKeyCache();
exports.SDK = SDK = SDK_1 = __decorate([
    tracing_1.traceMethods
], SDK);
const CURRENT_ACCOUNT_KEY = Symbol('current_account_key');
function isFunction(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Return the concatenated message of all exceptions in the AWS exception chain
 */
function allChainedExceptionMessages(e) {
    const ret = new Array();
    while (e) {
        ret.push(e.message);
        e = e.originalError;
    }
    return ret.join(': ');
}
/**
 * Return whether an error should not be recovered from
 */
function isUnrecoverableAwsError(e) {
    return e.code === 'ExpiredToken';
}
exports.isUnrecoverableAwsError = isUnrecoverableAwsError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFFL0IsaUNBQXNDO0FBQ3RDLG1EQUF3RDtBQUN4RCxxQ0FBa0M7QUFFbEMsZ0RBQWtEO0FBRWxELDRGQUE0RjtBQUM1RixzRUFBc0U7QUFDdEUsRUFBRTtBQUNGLDJGQUEyRjtBQUMzRixzQkFBc0I7QUFFdEIsMERBQTBEO0FBQzFELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ3hELE9BQU8sQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDaEUseURBQXlEO0FBRXpELElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLGtGQUFrRixDQUFDLENBQUM7QUFDdEcsQ0FBQztBQXdFRDs7R0FFRztBQUVJLElBQU0sR0FBRyxXQUFULE1BQU0sR0FBRztJQWtDZCxZQUNtQixZQUE2QixFQUM5QyxNQUFjLEVBQ2QsY0FBb0MsRUFBRSxFQUNyQixhQUF5QixFQUFFO1FBSDNCLGlCQUFZLEdBQVosWUFBWSxDQUFpQjtRQUc3QixlQUFVLEdBQVYsVUFBVSxDQUFpQjtRQS9COUM7O1dBRUc7UUFDYyxpQkFBWSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBRXBGOzs7OztXQUtHO1FBQ2MsK0JBQTBCLEdBQUcsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUssRUFBRSxFQUFFLENBQUM7UUFFckc7O1dBRUc7UUFDYyxvQkFBZSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVB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LENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNwQixDQUFDLEdBQUksQ0FBUyxDQUFDLGFBQWEsQ0FBQztJQUMvQixDQUFDO0lBQ0QsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHVCQUF1QixDQUFDLENBQVE7SUFDOUMsT0FBUSxDQUFTLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQztBQUM1QyxDQUFDO0FBRkQsMERBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgdHlwZSB7IENvbmZpZ3VyYXRpb25PcHRpb25zIH0gZnJvbSAnYXdzLXNkay9saWIvY29uZmlnLWJhc2UnO1xuaW1wb3J0IHsgZGVidWcsIHRyYWNlIH0gZnJvbSAnLi9fZW52JztcbmltcG9ydCB7IEFjY291bnRBY2Nlc3NLZXlDYWNoZSB9IGZyb20gJy4vYWNjb3VudC1jYWNoZSc7XG5pbXBvcnQgeyBjYWNoZWQgfSBmcm9tICcuL2NhY2hlZCc7XG5pbXBvcnQgeyBBY2NvdW50IH0gZnJvbSAnLi9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgdHJhY2VNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbC90cmFjaW5nJztcblxuLy8gV2UgbmVlZCB0byBtYXAgcmVnaW9ucyB0byBkb21haW4gc3VmZml4ZXMsIGFuZCB0aGUgU0RLIGFscmVhZHkgaGFzIGEgZnVuY3Rpb24gdG8gZG8gdGhpcy5cbi8vIEl0J3Mgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIGJ1dCBpdCdzIGFsc28gdW5saWtlbHkgdG8gZ28gYXdheS5cbi8vXG4vLyBSZXVzZSB0aGF0IGZ1bmN0aW9uLCBhbmQgYWRkIGEgc2FmZXR5IGNoZWNrLCBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgYnJlYWsgaWYgdGhleSBldmVyXG4vLyByZWZhY3RvciB0aGF0IGF3YXkuXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbmNvbnN0IHJlZ2lvblV0aWwgPSByZXF1aXJlKCdhd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnJyk7XG5yZXF1aXJlKCdhd3Mtc2RrL2xpYi9tYWludGVuYW5jZV9tb2RlX21lc3NhZ2UnKS5zdXBwcmVzcyA9IHRydWU7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cblxuaWYgKCFyZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyB2ZXJzaW9uIG9mIEFXUyBTREsgZm9yIEpTIGRvZXMgbm90IGhhdmUgdGhlIFxcJ2dldEVuZHBvaW50U3VmZml4XFwnIGZ1bmN0aW9uIScpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFMzQ2xpZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZiBBUElzIGFyZSB1c2VkIHRoYXQgcmVxdWlyZSBNRDUgY2hlY2tzdW1zLlxuICAgKlxuICAgKiBTb21lIFMzIEFQSXMgaW4gU0RLdjIgaGF2ZSBhIGJ1ZyB0aGF0IGFsd2F5cyByZXF1aXJlcyB0aGVtIHRvIHVzZSBhIE1ENSBjaGVja3N1bS5cbiAgICogVGhlc2UgQVBJcyBhcmUgbm90IGdvaW5nIHRvIGJlIHN1cHBvcnRlZCBpbiBhIEZJUFMgZW52aXJvbm1lbnQuXG4gICAqL1xuICBuZWVkc01kNUNoZWNrc3Vtcz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNESyB7XG4gIC8qKlxuICAgKiBUaGUgcmVnaW9uIHRoaXMgU0RLIGhhcyBiZWVuIGluc3RhbnRpYXRlZCBmb3JcbiAgICpcbiAgICogKEFzIGRpc3RpbmN0IGZyb20gdGhlIGBkZWZhdWx0UmVnaW9uKClgIG9uIFNka1Byb3ZpZGVyIHdoaWNoXG4gICAqIHJlcHJlc2VudHMgdGhlIHJlZ2lvbiBjb25maWd1cmVkIGluIHRoZSBkZWZhdWx0IGNvbmZpZykuXG4gICAqL1xuICByZWFkb25seSBjdXJyZW50UmVnaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBBY2NvdW50IHRoaXMgU0RLIGhhcyBiZWVuIGluc3RhbnRpYXRlZCBmb3JcbiAgICpcbiAgICogKEFzIGRpc3RpbmN0IGZyb20gdGhlIGBkZWZhdWx0QWNjb3VudCgpYCBvbiBTZGtQcm92aWRlciB3aGljaFxuICAgKiByZXByZXNlbnRzIHRoZSBhY2NvdW50IGF2YWlsYWJsZSBieSB1c2luZyBkZWZhdWx0IGNyZWRlbnRpYWxzKS5cbiAgICovXG4gIGN1cnJlbnRBY2NvdW50KCk6IFByb21pc2U8QWNjb3VudD47XG5cbiAgZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uOiBzdHJpbmcpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGdpdmVuIHN0cmluZyBhcyB0aGUgZXh0cmEgaW5mb3JtYXRpb24gdG8gcHV0IGludG8gdGhlIFVzZXItQWdlbnQgaGVhZGVyIGZvciBhbnkgcmVxdWVzdHMgaW52b2tlZCBieSB0aGlzIFNESy5cbiAgICogSWYgdGhlIHN0cmluZyBpcyAndW5kZWZpbmVkJywgdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cbiAgICovXG4gIGFwcGVuZEN1c3RvbVVzZXJBZ2VudCh1c2VyQWdlbnREYXRhPzogc3RyaW5nKTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gc3RyaW5nIGZyb20gdGhlIGV4dHJhIFVzZXItQWdlbnQgaGVhZGVyIGRhdGEgdXNlZCBmb3IgcmVxdWVzdHMgaW52b2tlZCBieSB0aGlzIFNESy5cbiAgICovXG4gIHJlbW92ZUN1c3RvbVVzZXJBZ2VudCh1c2VyQWdlbnREYXRhOiBzdHJpbmcpOiB2b2lkO1xuXG4gIGxhbWJkYSgpOiBBV1MuTGFtYmRhO1xuICBjbG91ZEZvcm1hdGlvbigpOiBBV1MuQ2xvdWRGb3JtYXRpb247XG4gIGVjMigpOiBBV1MuRUMyO1xuICBpYW0oKTogQVdTLklBTTtcbiAgc3NtKCk6IEFXUy5TU007XG4gIHMzKG9wdGlvbnM/OiBTM0NsaWVudE9wdGlvbnMpOiBBV1MuUzM7XG4gIHJvdXRlNTMoKTogQVdTLlJvdXRlNTM7XG4gIGVjcigpOiBBV1MuRUNSO1xuICBlY3MoKTogQVdTLkVDUztcbiAgZWxidjIoKTogQVdTLkVMQnYyO1xuICBzZWNyZXRzTWFuYWdlcigpOiBBV1MuU2VjcmV0c01hbmFnZXI7XG4gIGttcygpOiBBV1MuS01TO1xuICBzdGVwRnVuY3Rpb25zKCk6IEFXUy5TdGVwRnVuY3Rpb25zO1xuICBjb2RlQnVpbGQoKTogQVdTLkNvZGVCdWlsZDtcbiAgY2xvdWRXYXRjaExvZ3MoKTogQVdTLkNsb3VkV2F0Y2hMb2dzO1xuICBhcHBzeW5jKCk6IEFXUy5BcHBTeW5jO1xufVxuXG4vKipcbiAqIEFkZGl0aW9uYWwgU0RLIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNka09wdGlvbnMge1xuICAvKipcbiAgICogQWRkaXRpb25hbCBkZXNjcmlwdGl2ZSBzdHJpbmdzIHRoYXQgaW5kaWNhdGUgd2hlcmUgdGhlIFwiQXNzdW1lUm9sZVwiIGNyZWRlbnRpYWxzIGFyZSBjb21pbmcgZnJvbVxuICAgKlxuICAgKiBXaWxsIGJlIHByaW50ZWQgaW4gYW4gZXJyb3IgbWVzc2FnZSB0byBoZWxwIHVzZXJzIGRpYWdub3NlIGF1dGggcHJvYmxlbXMuXG4gICAqL1xuICByZWFkb25seSBhc3N1bWVSb2xlQ3JlZGVudGlhbHNTb3VyY2VEZXNjcmlwdGlvbj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBCYXNlIGZ1bmN0aW9uYWxpdHkgb2YgU0RLIHdpdGhvdXQgY3JlZGVudGlhbCBmZXRjaGluZ1xuICovXG5AdHJhY2VNZXRob2RzXG5leHBvcnQgY2xhc3MgU0RLIGltcGxlbWVudHMgSVNESyB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGFjY291bnRDYWNoZSA9IG5ldyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUoKTtcblxuICBwdWJsaWMgcmVhZG9ubHkgY3VycmVudFJlZ2lvbjogc3RyaW5nO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBDb25maWd1cmF0aW9uT3B0aW9ucztcblxuICAvKipcbiAgICogRGVmYXVsdCByZXRyeSBvcHRpb25zIGZvciBTREsgY2xpZW50cy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcmV0cnlPcHRpb25zID0geyBtYXhSZXRyaWVzOiA2LCByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiAzMDAgfSB9O1xuXG4gIC8qKlxuICAgKiBUaGUgbW9yZSBnZW5lcm91cyByZXRyeSBwb2xpY3kgZm9yIENsb3VkRm9ybWF0aW9uLCB3aGljaCBoYXMgYSAxIFRQTSBsaW1pdCBvbiBjZXJ0YWluIEFQSXMsXG4gICAqIHdoaWNoIGFyZSBhYnVuZGFudGx5IHVzZWQgZm9yIGRlcGxveW1lbnQgdHJhY2tpbmcsIC4uLlxuICAgKlxuICAgKiBTbyB3ZSdyZSBhbGxvd2luZyB3YXkgbW9yZSByZXRyaWVzLCBidXQgd2FpdGluZyBhIGJpdCBtb3JlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBjbG91ZEZvcm1hdGlvblJldHJ5T3B0aW9ucyA9IHsgbWF4UmV0cmllczogMTAsIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDFfMDAwIH0gfTtcblxuICAvKipcbiAgICogU1RTIGlzIHVzZWQgdG8gY2hlY2sgY3JlZGVudGlhbCB2YWxpZGl0eSwgZG9uJ3QgZG8gdG9vIG1hbnkgcmV0cmllcy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RzUmV0cnlPcHRpb25zID0geyBtYXhSZXRyaWVzOiAzLCByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiAxMDAgfSB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGhhdmUgcHJvb2YgdGhhdCB0aGUgY3JlZGVudGlhbHMgaGF2ZSBub3QgZXhwaXJlZFxuICAgKlxuICAgKiBXZSBuZWVkIHRvIGRvIHNvbWUgbWFudWFsIHBsdW1iaW5nIGFyb3VuZCB0aGlzIGJlY2F1c2UgdGhlIEpTIFNES3YyIHRyZWF0cyBgRXhwaXJlZFRva2VuYFxuICAgKiBhcyByZXRyaWFibGUgYW5kIHdlIGhhdmUgaGVmdHkgcmV0cmllcyBvbiBDRk4gY2FsbHMgbWFraW5nIHRoZSBDTEkgaGFuZyBmb3IgYSBnb29kIDE1IG1pbnV0ZXNcbiAgICogaWYgdGhlIGNyZWRlbnRpYWxzIGhhdmUgZXhwaXJlZC5cbiAgICovXG4gIHByaXZhdGUgX2NyZWRlbnRpYWxzVmFsaWRhdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBfY3JlZGVudGlhbHM6IEFXUy5DcmVkZW50aWFscyxcbiAgICByZWdpb246IHN0cmluZyxcbiAgICBodHRwT3B0aW9uczogQ29uZmlndXJhdGlvbk9wdGlvbnMgPSB7fSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNka09wdGlvbnM6IFNka09wdGlvbnMgPSB7fSkge1xuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi5odHRwT3B0aW9ucyxcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgY3JlZGVudGlhbHM6IF9jcmVkZW50aWFscyxcbiAgICAgIHJlZ2lvbixcbiAgICAgIGxvZ2dlcjogeyBsb2c6ICguLi5tZXNzYWdlcykgPT4gbWVzc2FnZXMuZm9yRWFjaChtID0+IHRyYWNlKCclcycsIG0pKSB9LFxuICAgIH07XG4gICAgdGhpcy5jdXJyZW50UmVnaW9uID0gcmVnaW9uO1xuICB9XG5cbiAgcHVibGljIGFwcGVuZEN1c3RvbVVzZXJBZ2VudCh1c2VyQWdlbnREYXRhPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCF1c2VyQWdlbnREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEN1c3RvbVVzZXJBZ2VudCA9IHRoaXMuY29uZmlnLmN1c3RvbVVzZXJBZ2VudDtcbiAgICB0aGlzLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSBjdXJyZW50Q3VzdG9tVXNlckFnZW50XG4gICAgICA/IGAke2N1cnJlbnRDdXN0b21Vc2VyQWdlbnR9ICR7dXNlckFnZW50RGF0YX1gXG4gICAgICA6IHVzZXJBZ2VudERhdGE7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlQ3VzdG9tVXNlckFnZW50KHVzZXJBZ2VudERhdGE6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY29uZmlnLmN1c3RvbVVzZXJBZ2VudCA9IHRoaXMuY29uZmlnLmN1c3RvbVVzZXJBZ2VudD8ucmVwbGFjZSh1c2VyQWdlbnREYXRhLCAnJyk7XG4gIH1cblxuICBwdWJsaWMgbGFtYmRhKCk6IEFXUy5MYW1iZGEge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkxhbWJkYSh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGNsb3VkRm9ybWF0aW9uKCk6IEFXUy5DbG91ZEZvcm1hdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuQ2xvdWRGb3JtYXRpb24oe1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi50aGlzLmNsb3VkRm9ybWF0aW9uUmV0cnlPcHRpb25zLFxuICAgIH0pKTtcbiAgfVxuXG4gIHB1YmxpYyBlYzIoKTogQVdTLkVDMiB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuRUMyKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgaWFtKCk6IEFXUy5JQU0ge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLklBTSh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIHNzbSgpOiBBV1MuU1NNIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5TU00odGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBzMyh7XG4gICAgbmVlZHNNZDVDaGVja3N1bXM6IGFwaVJlcXVpcmVzTWQ1Q2hlY2tzdW0gPSBmYWxzZSxcbiAgfTogUzNDbGllbnRPcHRpb25zID0ge30pOiBBV1MuUzMge1xuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcgfTtcblxuICAgIGlmICghYXBpUmVxdWlyZXNNZDVDaGVja3N1bSkge1xuICAgICAgLy8gSW4gRklQUyBlbmFibGVkIGVudmlyb25tZW50cywgdGhlIE1ENSBhbGdvcml0aG0gaXMgbm90IGF2YWlsYWJsZSBmb3IgdXNlIGluIGNyeXB0byBtb2R1bGUuXG4gICAgICAvLyBIb3dldmVyIGJ5IGRlZmF1bHQgdGhlIFMzIGNsaWVudCBpcyB1c2luZyBhbiBNRDUgY2hlY2tzdW0gZm9yIGNvbnRlbnQgaW50ZWdyaXR5IGNoZWNraW5nLlxuICAgICAgLy8gV2hpbGUgdGhpcyB1c2FnZSBpcyB0ZWNobmljYWxseSBhbGxvd2VkIGluIEZJUFMgKE1ENSBpcyBvbmx5IHByb2hpYml0ZWQgZm9yIGNyeXB0b2dyYXBoaWMgdXNlKSxcbiAgICAgIC8vIGluIHByYWN0aWNlIGl0IGlzIGp1c3QgZWFzaWVyIHRvIHVzZSBhbiBhbGxvd2VkIGNoZWNrc3VtIG1lY2hhbmlzbS5cbiAgICAgIC8vIFdlIGFyZSBkaXNhYmxpbmcgdGhlIFMzIGNvbnRlbnQgY2hlY2tzdW1zLCBhbmQgYXJlIHJlLWVuYWJsaW5nIHRoZSByZWd1bGFyIFNpZ1Y0IGJvZHkgc2lnbmluZy5cbiAgICAgIC8vIFNpZ1Y0IHVzZXMgU0hBMjU2IGZvciB0aGVpciBjb250ZW50IGNoZWNrc3VtLiBUaGlzIGNvbmZpZ3VyYXRpb24gbWF0Y2hlcyB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgLy8gb2YgdGhlIEFXUyBTREt2MyBhbmQgaXMgYSBzYWZlIGNob2ljZSBmb3IgYWxsIHVzZXJzLCBleGNlcHQgaW4gdGhlIGFib3ZlIEFQSXMuXG4gICAgICBjb25maWcuczNEaXNhYmxlQm9keVNpZ25pbmcgPSBmYWxzZTtcbiAgICAgIGNvbmZpZy5jb21wdXRlQ2hlY2tzdW1zID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuUzMoY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgcm91dGU1MygpOiBBV1MuUm91dGU1MyB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuUm91dGU1Myh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGVjcigpOiBBV1MuRUNSIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5FQ1IodGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBlY3MoKTogQVdTLkVDUyB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuRUNTKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgZWxidjIoKTogQVdTLkVMQnYyIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5FTEJ2Mih0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIHNlY3JldHNNYW5hZ2VyKCk6IEFXUy5TZWNyZXRzTWFuYWdlciB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuU2VjcmV0c01hbmFnZXIodGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBrbXMoKTogQVdTLktNUyB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuS01TKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgc3RlcEZ1bmN0aW9ucygpOiBBV1MuU3RlcEZ1bmN0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuU3RlcEZ1bmN0aW9ucyh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGNvZGVCdWlsZCgpOiBBV1MuQ29kZUJ1aWxkIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5Db2RlQnVpbGQodGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBjbG91ZFdhdGNoTG9ncygpOiBBV1MuQ2xvdWRXYXRjaExvZ3Mge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkNsb3VkV2F0Y2hMb2dzKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgYXBwc3luYygpOiBBV1MuQXBwU3luYyB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuQXBwU3luYyh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGN1cnJlbnRBY2NvdW50KCk6IFByb21pc2U8QWNjb3VudD4ge1xuICAgIC8vIEdldC9yZWZyZXNoIGlmIG5lY2Vzc2FyeSBiZWZvcmUgd2UgY2FuIGFjY2VzcyBgYWNjZXNzS2V5SWRgXG4gICAgYXdhaXQgdGhpcy5mb3JjZUNyZWRlbnRpYWxSZXRyaWV2YWwoKTtcblxuICAgIHJldHVybiBjYWNoZWQodGhpcywgQ1VSUkVOVF9BQ0NPVU5UX0tFWSwgKCkgPT4gU0RLLmFjY291bnRDYWNoZS5mZXRjaCh0aGlzLl9jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBvbmUsIHJlc29sdmUgZnJvbSBTVFMgYW5kIHN0b3JlIGluIGNhY2hlLlxuICAgICAgZGVidWcoJ0xvb2tpbmcgdXAgZGVmYXVsdCBhY2NvdW50IElEIGZyb20gU1RTJyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgQVdTLlNUUyh7IC4uLnRoaXMuY29uZmlnLCAuLi50aGlzLnN0c1JldHJ5T3B0aW9ucyB9KS5nZXRDYWxsZXJJZGVudGl0eSgpLnByb21pc2UoKTtcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IHJlc3VsdC5BY2NvdW50O1xuICAgICAgY29uc3QgcGFydGl0aW9uID0gcmVzdWx0LkFybiEuc3BsaXQoJzonKVsxXTtcbiAgICAgIGlmICghYWNjb3VudElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU1RTIGRpZG5cXCd0IHJldHVybiBhbiBhY2NvdW50IElEJyk7XG4gICAgICB9XG4gICAgICBkZWJ1ZygnRGVmYXVsdCBhY2NvdW50IElEOicsIGFjY291bnRJZCk7XG5cbiAgICAgIC8vIFNhdmUgYW5vdGhlciBTVFMgY2FsbCBsYXRlciBpZiB0aGlzIG9uZSBhbHJlYWR5IHN1Y2NlZWRlZFxuICAgICAgdGhpcy5fY3JlZGVudGlhbHNWYWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHsgYWNjb3VudElkLCBwYXJ0aXRpb24gfTtcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIERvbid0IHVzZSAtLSBvbmx5IHVzZWQgdG8gd3JpdGUgdGVzdHMgYXJvdW5kIGFzc3VtaW5nIHJvbGVzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGN1cnJlbnRDcmVkZW50aWFscygpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIGF3YWl0IHRoaXMuZm9yY2VDcmVkZW50aWFsUmV0cmlldmFsKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWRlbnRpYWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHJldHJpZXZhbCBvZiB0aGUgY3VycmVudCBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBSZWxldmFudCBpZiB0aGUgY3VycmVudCBjcmVkZW50aWFscyBhcmUgQXNzdW1lUm9sZSBjcmVkZW50aWFscyAtLSBkbyB0aGUgYWN0dWFsXG4gICAqIGxvb2t1cCwgYW5kIHRyYW5zbGF0ZSBhbnkgZXJyb3IgaW50byBhIHVzZWZ1bCBlcnJvciBtZXNzYWdlICh0YWtpbmcgaW50b1xuICAgKiBhY2NvdW50IGNyZWRlbnRpYWwgcHJvdmVuYW5jZSkuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZm9yY2VDcmVkZW50aWFsUmV0cmlldmFsKCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9jcmVkZW50aWFscy5nZXRQcm9taXNlKCk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoaXNVbnJlY292ZXJhYmxlQXdzRXJyb3IoZSkpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSByZWFzb24gdGhpcyB3b3VsZCBmYWlsIGlzIGlmIGl0IHdhcyBhbiBBc3N1bVJvbGUuIE90aGVyd2lzZSxcbiAgICAgIC8vIHJlYWRpbmcgZnJvbSBhbiBJTkkgZmlsZSBvciByZWFkaW5nIGVudiB2YXJpYWJsZXMgaXMgdW5saWtlbHkgdG8gZmFpbC5cbiAgICAgIGRlYnVnKGBBc3N1bWluZyByb2xlIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICAnQ291bGQgbm90IGFzc3VtZSByb2xlIGluIHRhcmdldCBhY2NvdW50JyxcbiAgICAgICAgLi4udGhpcy5zZGtPcHRpb25zLmFzc3VtZVJvbGVDcmVkZW50aWFsc1NvdXJjZURlc2NyaXB0aW9uXG4gICAgICAgICAgPyBbYHVzaW5nICR7dGhpcy5zZGtPcHRpb25zLmFzc3VtZVJvbGVDcmVkZW50aWFsc1NvdXJjZURlc2NyaXB0aW9ufWBdXG4gICAgICAgICAgOiBbXSxcbiAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAnLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhpcyByb2xlIGV4aXN0cyBpbiB0aGUgYWNjb3VudC4gSWYgaXQgZG9lc25cXCd0IGV4aXN0LCAocmUpLWJvb3RzdHJhcCB0aGUgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICd3aXRoIHRoZSByaWdodCBcXCctLXRydXN0XFwnLCB1c2luZyB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgdGhlIENESyBDTEkuJyxcbiAgICAgIF0uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBzdXJlIHRoZSB0aGUgY3VycmVudCBjcmVkZW50aWFscyBhcmUgbm90IGV4cGlyZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyB2YWxpZGF0ZUNyZWRlbnRpYWxzKCkge1xuICAgIGlmICh0aGlzLl9jcmVkZW50aWFsc1ZhbGlkYXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IG5ldyBBV1MuU1RTKHsgLi4udGhpcy5jb25maWcsIC4uLnRoaXMuc3RzUmV0cnlPcHRpb25zIH0pLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuICAgIHRoaXMuX2NyZWRlbnRpYWxzVmFsaWRhdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFbmRwb2ludFN1ZmZpeChyZWdpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJlZ2lvblV0aWwuZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB3cmFwcGluZyBvYmplY3QgZm9yIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2Ugb2JqZWN0XG4gICAqXG4gICAqIFJlc3BvbmRzIHRvIGZhaWx1cmVzIGluIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2UgY2FsbHMsIGluIHR3byBkaWZmZXJlbnRcbiAgICogd2F5czpcbiAgICpcbiAgICogLSBXaGVuIGVycm9ycyBhcmUgZW5jb3VudGVyZWQsIGxvZyB0aGUgZmFpbGluZyBjYWxsIGFuZCB0aGUgZXJyb3IgdGhhdFxuICAgKiAgIGl0IHRyaWdnZXJlZCAoYXQgZGVidWcgbGV2ZWwpLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBsYWNrIG9mXG4gICAqICAgc3RhY2sgdHJhY2VzIGluIE5vZGVKUyBvdGhlcndpc2UgbWFrZXMgaXQgdmVyeSBoYXJkIHRvIHN1c3Mgb3V0IHdoZXJlXG4gICAqICAgYSBjZXJ0YWluIEFXUyBlcnJvciBvY2N1cnJlZC5cbiAgICogLSBUaGUgSlMgU0RLIGhhcyBhIGZ1bm55IGJ1c2luZXNzIG9mIHdyYXBwaW5nIGFueSBjcmVkZW50aWFsLWJhc2VkIGVycm9yXG4gICAqICAgaW4gYSBzdXBlci1nZW5lcmljIChhbmQgaW4gb3VyIGNhc2Ugd3JvbmcpIGV4Y2VwdGlvbi4gSWYgd2UgdGhlbiB1c2UgYVxuICAgKiAgICdDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscycgYW5kIHRoZSB0YXJnZXQgcm9sZSBkb2Vzbid0IGV4aXN0LFxuICAgKiAgIHRoZSBlcnJvciBtZXNzYWdlIHRoYXQgc2hvd3MgdXAgYnkgZGVmYXVsdCBpcyBzdXBlciBtaXNsZWFkaW5nXG4gICAqICAgKGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9pc3N1ZXMvMzI3MikuIFdlIGNhbiBmaXggdGhpcyBiZWNhdXNlXG4gICAqICAgdGhlIGV4Y2VwdGlvbiBjb250YWlucyB0aGUgXCJpbm5lciBleGNlcHRpb25cIiwgc28gd2UgdW53cmFwIGFuZCB0aHJvd1xuICAgKiAgIHRoZSBjb3JyZWN0IGVycm9yIChcImNhbm5vdCBhc3N1bWUgcm9sZVwiKS5cbiAgICpcbiAgICogVGhlIHdyYXBwaW5nIGJ1c2luZXNzIGJlbG93IGlzIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiB5b3UnZCB0aGlua1xuICAgKiBiZWNhdXNlIHdlIG11c3QgaG9vayBpbnRvIHRoZSBgcHJvbWlzZSgpYCBtZXRob2Qgb2YgdGhlIG9iamVjdCB0aGF0J3MgYmVpbmdcbiAgICogcmV0dXJuZWQgZnJvbSB0aGUgbWV0aG9kcyBvZiB0aGUgb2JqZWN0IHRoYXQgd2Ugd3JhcCwgc28gdGhlcmUncyB0d29cbiAgICogbGV2ZWxzIG9mIHdyYXBwaW5nIGdvaW5nIG9uLCBhbmQgYWxzbyBzb21lIGV4Y2VwdGlvbnMgdG8gdGhlIHdyYXBwaW5nIG1hZ2ljLlxuICAgKi9cbiAgcHJpdmF0ZSB3cmFwU2VydmljZUVycm9ySGFuZGxpbmc8QSBleHRlbmRzIG9iamVjdD4oc2VydmljZU9iamVjdDogQSk6IEEge1xuICAgIGNvbnN0IGNsYXNzT2JqZWN0ID0gc2VydmljZU9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb3h5KHNlcnZpY2VPYmplY3QsIHtcbiAgICAgIGdldChvYmo6IEEsIHByb3A6IHN0cmluZykge1xuICAgICAgICBjb25zdCByZWFsID0gKG9iaiBhcyBhbnkpW3Byb3BdO1xuICAgICAgICAvLyBUaGluZ3Mgd2UgZG9uJ3Qgd2FudCB0byBpbnRlcmNlcHQ6XG4gICAgICAgIC8vIC0gQW55dGhpbmcgdGhhdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyAtICdjb25zdHJ1Y3RvcicsIHMzLnVwbG9hZCgpIHdpbGwgdXNlIHRoaXMgdG8gZG8gc29tZSBtYWdpYyBhbmQgd2UgbmVlZCB0aGUgdW5kZXJseWluZyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgLy8gLSBBbnkgbWV0aG9kIHRoYXQncyBub3Qgb24gdGhlIHNlcnZpY2UgY2xhc3MgKGRvIG5vdCBpbnRlcmNlcHQgJ21ha2VSZXF1ZXN0JyBhbmQgb3RoZXIgaGVscGVycykuXG4gICAgICAgIGlmIChwcm9wID09PSAnY29uc3RydWN0b3InIHx8ICFjbGFzc09iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNGdW5jdGlvbihyZWFsKSkgeyByZXR1cm4gcmVhbDsgfVxuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgbXVzdCBiZSBhIGZ1bmN0aW9uKCkgYW5kIG5vdCBhbiAoKSA9PiB7XG4gICAgICAgIC8vIGJlY2F1c2UgSSBuZWVkICd0aGlzJyB0byBiZSBkeW5hbWljYWxseSBib3VuZCBhbmQgbm90IHN0YXRpY2FsbHkgYm91bmQuXG4gICAgICAgIC8vIElmIHlvdXIgbGludGVyIGNvbXBsYWlucyBkb24ndCBsaXN0ZW4gdG8gaXQhXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBhbnkpIHtcbiAgICAgICAgICAvLyBDYWxsIHRoZSB1bmRlcmx5aW5nIGZ1bmN0aW9uLiBJZiBpdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgcHJvbWlzZSgpXG4gICAgICAgICAgLy8gbWV0aG9kIG9uIGl0LCB3cmFwIHRoYXQgJ3Byb21pc2UnIG1ldGhvZC5cbiAgICAgICAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVhbC5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgIC8vIERvbid0IGludGVyY2VwdCB1bmxlc3MgdGhlIHJldHVybiB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhICcucHJvbWlzZSgpJyBtZXRob2QuXG4gICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPT0gJ29iamVjdCcgfHwgIXJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZTsgfVxuICAgICAgICAgIGlmICghKCdwcm9taXNlJyBpbiByZXNwb25zZSkpIHsgcmV0dXJuIHJlc3BvbnNlOyB9XG5cbiAgICAgICAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb21pc2UgbWV0aG9kIHJlcGxhY2VkIHdpdGggYSB3cmFwcGVyIHdoaWNoIHdpbGxcbiAgICAgICAgICAvLyBkbyBhZGRpdGlvbmFsIHRoaW5ncyB0byBlcnJvcnMuXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShyZXNwb25zZSksIHtcbiAgICAgICAgICAgIHByb21pc2UoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5wcm9taXNlKCkuY2F0Y2goKGU6IEVycm9yICYgeyBjb2RlPzogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICAgICAgICBlID0gc2VsZi5tYWtlRGV0YWlsZWRFeGNlcHRpb24oZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoYENhbGwgZmFpbGVkOiAke3Byb3B9KCR7SlNPTi5zdHJpbmdpZnkoYXJnc1swXSl9KSA9PiAke2UubWVzc2FnZX0gKGNvZGU9JHtlLmNvZGV9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgLy8gUmUtJ3Rocm93JyB0aGUgbmV3IGVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBhIG1vcmUgZGV0YWlsZWQgZXJyb3Igb3V0IG9mIGEgZ2VuZXJpYyBlcnJvciBpZiB3ZSBjYW5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBhbiBlcnJvciBhYm91dCBBc3N1bWluZyBSb2xlcywgYWRkIGluIHRoZSBjb250ZXh0IHNob3dpbmcgdGhlXG4gICAqIGNoYWluIG9mIGNyZWRlbnRpYWxzIHdlIHVzZWQgdG8gdHJ5IHRvIGFzc3VtZSB0aGUgcm9sZS5cbiAgICovXG4gIHByaXZhdGUgbWFrZURldGFpbGVkRXhjZXB0aW9uKGU6IEVycm9yKTogRXJyb3Ige1xuICAgIC8vIFRoaXMgaXMgdGhlIHN1cGVyLWdlbmVyaWMgXCJzb21ldGhpbmcncyB3cm9uZ1wiIGVycm9yIHRoYXQgdGhlIEpTIFNESyB3cmFwcyBvdGhlciBlcnJvcnMgaW4uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2Jsb2IvZjBhYzJlNTM0NTdjNzUxMjg4M2QwNjc3MDEzZWFjYWFkNmNkOGExOS9saWIvZXZlbnRfbGlzdGVuZXJzLmpzI0w4NFxuICAgIGlmICh0eXBlb2YgZS5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlLm1lc3NhZ2Uuc3RhcnRzV2l0aCgnTWlzc2luZyBjcmVkZW50aWFscyBpbiBjb25maWcnKSkge1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSAoZSBhcyBhbnkpLm9yaWdpbmFsRXJyb3I7XG4gICAgICBpZiAob3JpZ2luYWwpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgU0RLIGRvZXMgYSAndXRpbC5jb3B5JywgdGhleSBsb3NlIHRoZSBFcnJvci1uZXNzIG9mIHRoZSBpbm5lciBlcnJvclxuICAgICAgICAvLyAodGhleSBjb3B5IHRoZSBFcnJvcidzIHByb3BlcnRpZXMgaW50byBhIHBsYWluIG9iamVjdCkgc28gbWFrZSBpdCBhbiBFcnJvciBvYmplY3QgYWdhaW4uXG4gICAgICAgIGUgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcigpLCBvcmlnaW5hbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGVycm9yIG1pZ2h0IHN0aWxsIGJlIGEgZ2VuZXJpYyBcIkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIGZhaWxlZFwiXG4gICAgLy8gZXJyb3Igd2hpY2ggd3JhcHMgdGhlIFJFQUwgZXJyb3IgKEFzc3VtZVJvbGUgZmFpbGVkKS4gV2UncmUgZ29pbmcgdG8gcmVwbGFjZSB0aGUgZXJyb3JcbiAgICAvLyBtZXNzYWdlIHdpdGggb25lIHRoYXQncyBtb3JlIGxpa2VseSB0byBoZWxwIHVzZXJzLCBhbmQgdGVsbCB0aGVtIHRoZSBtb3N0IHByb2JhYmxlXG4gICAgLy8gZml4IChib290c3RyYXBwaW5nKS4gVGhlIHVuZGVybHlpbmcgc2VydmljZSBjYWxsIGZhaWx1cmUgd2lsbCBiZSBhcHBlbmRlZCBiZWxvdy5cbiAgICBpZiAoZS5tZXNzYWdlID09PSAnQ291bGQgbm90IGxvYWQgY3JlZGVudGlhbHMgZnJvbSBDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscycpIHtcbiAgICAgIGUubWVzc2FnZSA9IFtcbiAgICAgICAgJ0NvdWxkIG5vdCBhc3N1bWUgcm9sZSBpbiB0YXJnZXQgYWNjb3VudCcsXG4gICAgICAgIC4uLnRoaXMuc2RrT3B0aW9ucy5hc3N1bWVSb2xlQ3JlZGVudGlhbHNTb3VyY2VEZXNjcmlwdGlvblxuICAgICAgICAgID8gW2B1c2luZyAke3RoaXMuc2RrT3B0aW9ucy5hc3N1bWVSb2xlQ3JlZGVudGlhbHNTb3VyY2VEZXNjcmlwdGlvbn1gXVxuICAgICAgICAgIDogW10sXG4gICAgICAgICcoZGlkIHlvdSBib290c3RyYXAgdGhlIGVudmlyb25tZW50IHdpdGggdGhlIHJpZ2h0IFxcJy0tdHJ1c3RcXCdzPyknLFxuICAgICAgXS5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSB0aGUgbWVzc2FnZSBvbiB0aGlzIGVycm9yIHdpdGggYSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbm5lciBlcnJvciBtZXNzYWdlcy5cbiAgICAvLyBNdXN0IG1vcmUgY2xlYXIgd2hhdCdzIGdvaW5nIG9uIHRoYXQgd2F5LlxuICAgIGUubWVzc2FnZSA9IGFsbENoYWluZWRFeGNlcHRpb25NZXNzYWdlcyhlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5jb25zdCBDVVJSRU5UX0FDQ09VTlRfS0VZID0gU3ltYm9sKCdjdXJyZW50X2FjY291bnRfa2V5Jyk7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeDogYW55KTogeCBpcyAoLi4uYXJnczogYW55W10pID0+IGFueSB7XG4gIHJldHVybiB4ICYmIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb25jYXRlbmF0ZWQgbWVzc2FnZSBvZiBhbGwgZXhjZXB0aW9ucyBpbiB0aGUgQVdTIGV4Y2VwdGlvbiBjaGFpblxuICovXG5mdW5jdGlvbiBhbGxDaGFpbmVkRXhjZXB0aW9uTWVzc2FnZXMoZTogRXJyb3IgfCB1bmRlZmluZWQpIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgd2hpbGUgKGUpIHtcbiAgICByZXQucHVzaChlLm1lc3NhZ2UpO1xuICAgIGUgPSAoZSBhcyBhbnkpLm9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCc6ICcpO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGFuIGVycm9yIHNob3VsZCBub3QgYmUgcmVjb3ZlcmVkIGZyb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5yZWNvdmVyYWJsZUF3c0Vycm9yKGU6IEVycm9yKSB7XG4gIHJldHVybiAoZSBhcyBhbnkpLmNvZGUgPT09ICdFeHBpcmVkVG9rZW4nO1xufVxuIl19