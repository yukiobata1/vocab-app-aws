"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate, hotswapPropertyOverrides) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['ContainerDefinitions']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter(r => r.Type !== 'AWS::ECS::Service');
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${await taskDefinitionResource.Family}'`,
                ...ecsServicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                // The SDK requires more properties here than its worth doing explicit typing for
                // instead, just use all the old values in the diff to fill them in implicitly
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(taskDefinitionResource, common_1.lowerCaseFirstCharacter, {
                    // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
                    // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                });
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
                const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
                let ecsHotswapProperties = hotswapPropertyOverrides.ecsHotswapProperties;
                let minimumHealthyPercent = ecsHotswapProperties?.minimumHealthyPercent;
                let maximumHealthyPercent = ecsHotswapProperties?.maximumHealthyPercent;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                const servicePerClusterUpdates = {};
                for (const ecsService of ecsServicesReferencingTaskDef) {
                    const clusterName = ecsService.serviceArn.split('/')[1];
                    const existingClusterPromises = servicePerClusterUpdates[clusterName];
                    let clusterPromises;
                    if (existingClusterPromises) {
                        clusterPromises = existingClusterPromises;
                    }
                    else {
                        clusterPromises = [];
                        servicePerClusterUpdates[clusterName] = clusterPromises;
                    }
                    // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                    // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount.
                    clusterPromises.push({
                        promise: sdk.ecs().updateService({
                            service: ecsService.serviceArn,
                            taskDefinition: taskDefRevArn,
                            cluster: clusterName,
                            forceNewDeployment: true,
                            deploymentConfiguration: {
                                minimumHealthyPercent: minimumHealthyPercent !== undefined ? minimumHealthyPercent : 0,
                                maximumPercent: maximumHealthyPercent !== undefined ? maximumHealthyPercent : undefined,
                            },
                        }).promise(),
                        ecsService: ecsService,
                    });
                }
                // Limited set of updates per cluster
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(Object.values(servicePerClusterUpdates)
                    .map(clusterUpdates => {
                    // Limited set of updates per cluster
                    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                    return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
                }));
                // Step 3 - wait for the service deployments triggered in Step 2 to finish
                // configure a custom Waiter
                sdk.ecs().api.waiters.deploymentCompleted = {
                    name: 'DeploymentCompleted',
                    operation: 'describeServices',
                    delay: 6,
                    maxAttempts: 100,
                    acceptors: [
                        {
                            matcher: 'pathAny',
                            argument: 'failures[].reason',
                            expected: 'MISSING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'DRAINING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'INACTIVE',
                            state: 'failure',
                        },
                        // failure if any services report a deployment with status FAILED
                        {
                            matcher: 'path',
                            argument: "length(services[].deployments[? rolloutState == 'FAILED'][]) > `0`",
                            expected: true,
                            state: 'failure',
                        },
                        // wait for all services to report only a single deployment
                        {
                            matcher: 'path',
                            argument: 'length(services[? length(deployments) > `1`]) == `0`',
                            expected: true,
                            state: 'success',
                        },
                    ],
                };
                // create a custom Waiter that uses the deploymentCompleted configuration added above
                const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentCompleted');
                // wait for all of the waiters to finish
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
                    return deploymentWaiter.wait({
                        cluster: clusterName,
                        services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
                    }).promise();
                }));
            },
        });
    }
    return ret;
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource ?? {}),
            Family: undefined,
        }),
        Family: family,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixxQ0FBa007QUFJM0wsS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUNqQixNQUFtQyxFQUNuQyxtQkFBbUQsRUFDbkQsd0JBQWtEO0lBRWxELHlFQUF5RTtJQUN6RSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFLENBQUM7UUFDeEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQXdCLEVBQUUsQ0FBQztJQUVwQyxxRkFBcUY7SUFDckYscUZBQXFGO0lBQ3JGLHVEQUF1RDtJQUN2RCxNQUFNLGlCQUFpQixHQUFHLElBQUEsd0JBQWUsRUFBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7SUFDNUUsaUJBQWlCLENBQUMsb0NBQW9DLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFNUQsdUVBQXVFO0lBQ3ZFLE1BQU0sMkJBQTJCLEdBQUcsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEYsTUFBTSxxQ0FBcUMsR0FBRywyQkFBMkIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUFDLENBQUM7SUFDdEgsTUFBTSw2QkFBNkIsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO0lBQzlELEtBQUssTUFBTSxrQkFBa0IsSUFBSSxxQ0FBcUMsRUFBRSxDQUFDO1FBQ3ZFLE1BQU0sVUFBVSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0YsSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUNmLDZCQUE2QixDQUFDLElBQUksQ0FBQyxFQUFF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LENBQUMsNkJBQTZCLENBQUMsU0FBUyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzNILElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUNyQiwyRkFBMkY7UUFDM0YseUNBQXlDO1FBQ3pDLE9BQU87SUFDVCxDQUFDO0lBQ0QsOEdBQThHO0lBQzlHLHNCQUFzQjtJQUN0QixNQUFNLG9CQUFvQixHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEQsTUFBTSxNQUFNLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDNUMsNkhBQTZIO1FBQzdILDREQUE0RDtRQUM1RCxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxnR0FBZ0c7UUFDaEcsQ0FBQyxDQUFDLGVBQWUsQ0FBQztJQUNwQiw4RkFBOEY7SUFDOUYsT0FBTztRQUNMLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQztZQUNqRCxHQUFHLENBQUMsc0JBQXNCLElBQUksRUFBRSxDQUFDO1lBQ2pDLE1BQU0sRUFBRSxTQUFTO1NBQ2xCLENBQUM7UUFDRixNQUFNLEVBQUUsTUFBTTtLQUNmLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcFJlc3VsdCwgY2xhc3NpZnlDaGFuZ2VzLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcywgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgdHJhbnNmb3JtT2JqZWN0S2V5cyB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZUVjc1NlcnZpY2VDaGFuZ2UoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyB0aGUgb25seSByZXNvdXJjZSBjaGFuZ2Ugd2UgY2FuIGV2YWx1YXRlIGhlcmUgaXMgYW4gRUNTIFRhc2tEZWZpbml0aW9uXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSAhPT0gJ0FXUzo6RUNTOjpUYXNrRGVmaW5pdGlvbicpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcblxuICAvLyBXZSBvbmx5IGFsbG93IGEgY2hhbmdlIGluIHRoZSBDb250YWluZXJEZWZpbml0aW9ucyBvZiB0aGUgVGFza0RlZmluaXRpb24gZm9yIG5vdyAtXG4gIC8vIGl0IGNvbnRhaW5zIHRoZSBpbWFnZSBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBzbyBzZWVtcyBsaWtlIGEgc2FmZSBiZXQgZm9yIG5vdy5cbiAgLy8gV2UgbWlnaHQgcmV2aXNpdCB0aGlzIGRlY2lzaW9uIGluIHRoZSBmdXR1cmUgdGhvdWdoIVxuICBjb25zdCBjbGFzc2lmaWVkQ2hhbmdlcyA9IGNsYXNzaWZ5Q2hhbmdlcyhjaGFuZ2UsIFsnQ29udGFpbmVyRGVmaW5pdGlvbnMnXSk7XG4gIGNsYXNzaWZpZWRDaGFuZ2VzLnJlcG9ydE5vbkhvdHN3YXBwYWJsZVByb3BlcnR5Q2hhbmdlcyhyZXQpO1xuXG4gIC8vIGZpbmQgYWxsIEVDUyBTZXJ2aWNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgVGFza0RlZmluaXRpb24gdGhhdCBjaGFuZ2VkXG4gIGNvbnN0IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dpY2FsSWQpO1xuICBjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcihyID0+IHIuVHlwZSA9PT0gJ0FXUzo6RUNTOjpTZXJ2aWNlJyk7XG4gIGNvbnN0IGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gbmV3IEFycmF5PEVjc1NlcnZpY2U+KCk7XG4gIGZvciAoY29uc3QgZWNzU2VydmljZVJlc291cmNlIG9mIGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYpIHtcbiAgICBjb25zdCBzZXJ2aWNlQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUGh5c2ljYWxOYW1lRm9yKGVjc1NlcnZpY2VSZXNvdXJjZS5Mb2dpY2FsSWQpO1xuICAgIGlmIChzZXJ2aWNlQXJuKSB7XG4gICAgICBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5wdXNoKHsgc2VydmljZUFybiB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyByZXNvdXJjZXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlIGluIEZBTExfQkFDSyBtb2RlXG4gICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKHJldCwgY2hhbmdlLCB1bmRlZmluZWQsICdObyBFQ1Mgc2VydmljZXMgcmVmZXJlbmNlIHRoZSBjaGFuZ2VkIHRhc2sgZGVmaW5pdGlvbicsIGZhbHNlKTtcbiAgfSBpZiAocmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA+IGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCkge1xuICAgIC8vIGlmIHNvbWV0aGluZyBiZXNpZGVzIGFuIEVDUyBTZXJ2aWNlIGlzIHJlZmVyZW5jaW5nIHRoZSBUYXNrRGVmaW5pdGlvbixcbiAgICAvLyBob3Rzd2FwIGlzIG5vdCBwb3NzaWJsZSBpbiBGQUxMX0JBQ0sgbW9kZVxuICAgIGNvbnN0IG5vbkVjc1NlcnZpY2VUYXNrRGVmUmVmcyA9IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5maWx0ZXIociA9PiByLlR5cGUgIT09ICdBV1M6OkVDUzo6U2VydmljZScpO1xuICAgIGZvciAoY29uc3QgdGFza1JlZiBvZiBub25FY3NTZXJ2aWNlVGFza0RlZlJlZnMpIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCBgQSByZXNvdXJjZSAnJHt0YXNrUmVmLkxvZ2ljYWxJZH0nIHdpdGggVHlwZSAnJHt0YXNrUmVmLlR5cGV9JyB0aGF0IGlzIG5vdCBhbiBFQ1MgU2VydmljZSB3YXMgZm91bmQgcmVmZXJlbmNpbmcgdGhlIGNoYW5nZWQgVGFza0RlZmluaXRpb24gJyR7bG9naWNhbElkfSdgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcyA9IE9iamVjdC5rZXlzKGNsYXNzaWZpZWRDaGFuZ2VzLmhvdHN3YXBwYWJsZVByb3BzKTtcbiAgaWYgKG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB0YXNrRGVmaW5pdGlvblJlc291cmNlID0gYXdhaXQgcHJlcGFyZVRhc2tEZWZpbml0aW9uQ2hhbmdlKGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGxvZ2ljYWxJZCwgY2hhbmdlKTtcbiAgICByZXQucHVzaCh7XG4gICAgICBob3Rzd2FwcGFibGU6IHRydWUsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZS5UeXBlLFxuICAgICAgcHJvcHNDaGFuZ2VkOiBuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcyxcbiAgICAgIHNlcnZpY2U6ICdlY3Mtc2VydmljZScsXG4gICAgICByZXNvdXJjZU5hbWVzOiBbXG4gICAgICAgIGBFQ1MgVGFzayBEZWZpbml0aW9uICcke2F3YWl0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2UuRmFtaWx5fSdgLFxuICAgICAgICAuLi5lY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5tYXAoZWNzU2VydmljZSA9PiBgRUNTIFNlcnZpY2UgJyR7ZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMl19J2ApLFxuICAgICAgXSxcbiAgICAgIGFwcGx5OiBhc3luYyAoc2RrOiBJU0RLKSA9PiB7XG4gICAgICAgIC8vIFN0ZXAgMSAtIHVwZGF0ZSB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiwgY3JlYXRpbmcgYSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgLy8gd2UgbmVlZCB0byBsb3dlcmNhc2UgdGhlIGV2YWx1YXRlZCBUYXNrRGVmIGZyb20gQ2xvdWRGb3JtYXRpb24sXG4gICAgICAgIC8vIGFzIHRoZSBBV1MgU0RLIHVzZXMgbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIGZvciB0aGVzZVxuXG4gICAgICAgIC8vIFRoZSBTREsgcmVxdWlyZXMgbW9yZSBwcm9wZXJ0aWVzIGhlcmUgdGhhbiBpdHMgd29ydGggZG9pbmcgZXhwbGljaXQgdHlwaW5nIGZvclxuICAgICAgICAvLyBpbnN0ZWFkLCBqdXN0IHVzZSBhbGwgdGhlIG9sZCB2YWx1ZXMgaW4gdGhlIGRpZmYgdG8gZmlsbCB0aGVtIGluIGltcGxpY2l0bHlcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlZFRhc2tEZWYgPSB0cmFuc2Zvcm1PYmplY3RLZXlzKHRhc2tEZWZpbml0aW9uUmVzb3VyY2UsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLCB7XG4gICAgICAgICAgLy8gQWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgdGFrZSBhcmJpdHJhcnkgc3RyaW5nIGFzIGtleXMgaS5lLiB7IFwic3RyaW5nXCIgOiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uRUNTL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb24uaHRtbCNBUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbl9SZXF1ZXN0U3ludGF4XG4gICAgICAgICAgQ29udGFpbmVyRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgIERvY2tlckxhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgIEZpcmVsZW5zQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBPcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIExvZ0NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBWb2x1bWVzOiB7XG4gICAgICAgICAgICBEb2NrZXJWb2x1bWVDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIERyaXZlck9wdHM6IHRydWUsXG4gICAgICAgICAgICAgIExhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlID0gYXdhaXQgc2RrLmVjcygpLnJlZ2lzdGVyVGFza0RlZmluaXRpb24obG93ZXJjYXNlZFRhc2tEZWYpLnByb21pc2UoKTtcbiAgICAgICAgY29uc3QgdGFza0RlZlJldkFybiA9IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlLnRhc2tEZWZpbml0aW9uPy50YXNrRGVmaW5pdGlvbkFybjtcblxuICAgICAgICBsZXQgZWNzSG90c3dhcFByb3BlcnRpZXMgPSBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMuZWNzSG90c3dhcFByb3BlcnRpZXM7XG4gICAgICAgIGxldCBtaW5pbXVtSGVhbHRoeVBlcmNlbnQgPSBlY3NIb3Rzd2FwUHJvcGVydGllcz8ubWluaW11bUhlYWx0aHlQZXJjZW50O1xuICAgICAgICBsZXQgbWF4aW11bUhlYWx0aHlQZXJjZW50ID0gZWNzSG90c3dhcFByb3BlcnRpZXM/Lm1heGltdW1IZWFsdGh5UGVyY2VudDtcblxuICAgICAgICAvLyBTdGVwIDIgLSB1cGRhdGUgdGhlIHNlcnZpY2VzIHVzaW5nIHRoYXQgVGFza0RlZmluaXRpb24gdG8gcG9pbnQgdG8gdGhlIG5ldyBUYXNrRGVmaW5pdGlvbiBSZXZpc2lvblxuICAgICAgICBjb25zdCBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXM6IHsgW2NsdXN0ZXI6IHN0cmluZ106IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+OyBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+IH0gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBlY3NTZXJ2aWNlIG9mIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmKSB7XG4gICAgICAgICAgY29uc3QgY2x1c3Rlck5hbWUgPSBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcblxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2x1c3RlclByb21pc2VzID0gc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXTtcbiAgICAgICAgICBsZXQgY2x1c3RlclByb21pc2VzOiBBcnJheTx7IHByb21pc2U6IFByb21pc2U8YW55PjsgZWNzU2VydmljZTogRWNzU2VydmljZSB9PjtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJQcm9taXNlcyA9IGV4aXN0aW5nQ2x1c3RlclByb21pc2VzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlc1tjbHVzdGVyTmFtZV0gPSBjbHVzdGVyUHJvbWlzZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZvcmNpbmcgTmV3IERlcGxveW1lbnQgYW5kIHNldHRpbmcgTWluaW11bSBIZWFsdGh5IFBlcmNlbnQgdG8gMC5cbiAgICAgICAgICAvLyBBcyBDREsgSG90U3dhcCBpcyBkZXZlbG9wbWVudCBvbmx5LCB0aGlzIHNlZW1zIHRoZSBtb3N0IGVmZmljaWVudCB3YXkgdG8gZW5zdXJlIGFsbCB0YXNrcyBhcmUgcmVwbGFjZWQgaW1tZWRpYXRlbHksIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luYWwgYW1vdW50LlxuICAgICAgICAgIGNsdXN0ZXJQcm9taXNlcy5wdXNoKHtcbiAgICAgICAgICAgIHByb21pc2U6IHNkay5lY3MoKS51cGRhdGVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgc2VydmljZTogZWNzU2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgICAgICB0YXNrRGVmaW5pdGlvbjogdGFza0RlZlJldkFybixcbiAgICAgICAgICAgICAgY2x1c3RlcjogY2x1c3Rlck5hbWUsXG4gICAgICAgICAgICAgIGZvcmNlTmV3RGVwbG95bWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGVwbG95bWVudENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtSGVhbHRoeVBlcmNlbnQ6IG1pbmltdW1IZWFsdGh5UGVyY2VudCAhPT0gdW5kZWZpbmVkID8gbWluaW11bUhlYWx0aHlQZXJjZW50IDogMCxcbiAgICAgICAgICAgICAgICBtYXhpbXVtUGVyY2VudDogbWF4aW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgPyBtYXhpbXVtSGVhbHRoeVBlcmNlbnQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS5wcm9taXNlKCksXG4gICAgICAgICAgICBlY3NTZXJ2aWNlOiBlY3NTZXJ2aWNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIExpbWl0ZWQgc2V0IG9mIHVwZGF0ZXMgcGVyIGNsdXN0ZXJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzKVxuICAgICAgICAgIC5tYXAoY2x1c3RlclVwZGF0ZXMgPT4ge1xuICAgICAgICAgICAgLy8gTGltaXRlZCBzZXQgb2YgdXBkYXRlcyBwZXIgY2x1c3RlclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2x1c3RlclVwZGF0ZXMubWFwKHNlcnZpY2VVcGRhdGUgPT4gc2VydmljZVVwZGF0ZS5wcm9taXNlKSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3RlcCAzIC0gd2FpdCBmb3IgdGhlIHNlcnZpY2UgZGVwbG95bWVudHMgdHJpZ2dlcmVkIGluIFN0ZXAgMiB0byBmaW5pc2hcbiAgICAgICAgLy8gY29uZmlndXJlIGEgY3VzdG9tIFdhaXRlclxuICAgICAgICAoc2RrLmVjcygpIGFzIGFueSkuYXBpLndhaXRlcnMuZGVwbG95bWVudENvbXBsZXRlZCA9IHtcbiAgICAgICAgICBuYW1lOiAnRGVwbG95bWVudENvbXBsZXRlZCcsXG4gICAgICAgICAgb3BlcmF0aW9uOiAnZGVzY3JpYmVTZXJ2aWNlcycsXG4gICAgICAgICAgZGVsYXk6IDYsXG4gICAgICAgICAgbWF4QXR0ZW1wdHM6IDEwMCxcbiAgICAgICAgICBhY2NlcHRvcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ2ZhaWx1cmVzW10ucmVhc29uJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdNSVNTSU5HJyxcbiAgICAgICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICAgICAgYXJndW1lbnQ6ICdzZXJ2aWNlc1tdLnN0YXR1cycsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiAnRFJBSU5JTkcnLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdJTkFDVElWRScsXG4gICAgICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBmYWlsdXJlIGlmIGFueSBzZXJ2aWNlcyByZXBvcnQgYSBkZXBsb3ltZW50IHdpdGggc3RhdHVzIEZBSUxFRFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aCcsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiBcImxlbmd0aChzZXJ2aWNlc1tdLmRlcGxveW1lbnRzWz8gcm9sbG91dFN0YXRlID09ICdGQUlMRUQnXVtdKSA+IGAwYFwiLFxuICAgICAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGFsbCBzZXJ2aWNlcyB0byByZXBvcnQgb25seSBhIHNpbmdsZSBkZXBsb3ltZW50XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICAgICAgYXJndW1lbnQ6ICdsZW5ndGgoc2VydmljZXNbPyBsZW5ndGgoZGVwbG95bWVudHMpID4gYDFgXSkgPT0gYDBgJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHN0YXRlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSBhIGN1c3RvbSBXYWl0ZXIgdGhhdCB1c2VzIHRoZSBkZXBsb3ltZW50Q29tcGxldGVkIGNvbmZpZ3VyYXRpb24gYWRkZWQgYWJvdmVcbiAgICAgICAgY29uc3QgZGVwbG95bWVudFdhaXRlciA9IG5ldyAoQVdTIGFzIGFueSkuUmVzb3VyY2VXYWl0ZXIoc2RrLmVjcygpLCAnZGVwbG95bWVudENvbXBsZXRlZCcpO1xuICAgICAgICAvLyB3YWl0IGZvciBhbGwgb2YgdGhlIHdhaXRlcnMgdG8gZmluaXNoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXMpLm1hcCgoW2NsdXN0ZXJOYW1lLCBzZXJ2aWNlVXBkYXRlc10pID0+IHtcbiAgICAgICAgICByZXR1cm4gZGVwbG95bWVudFdhaXRlci53YWl0KHtcbiAgICAgICAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgICAgICAgICAgc2VydmljZXM6IHNlcnZpY2VVcGRhdGVzLm1hcChzZXJ2aWNlVXBkYXRlID0+IHNlcnZpY2VVcGRhdGUuZWNzU2VydmljZS5zZXJ2aWNlQXJuKSxcbiAgICAgICAgICB9KS5wcm9taXNlKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5pbnRlcmZhY2UgRWNzU2VydmljZSB7XG4gIHJlYWRvbmx5IHNlcnZpY2VBcm46IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVRhc2tEZWZpbml0aW9uQ2hhbmdlKFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsIGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbikge1xuICBjb25zdCB0YXNrRGVmaW5pdGlvblJlc291cmNlOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfSA9IHtcbiAgICAuLi5jaGFuZ2Uub2xkVmFsdWUuUHJvcGVydGllcyxcbiAgICBDb250YWluZXJEZWZpbml0aW9uczogY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LkNvbnRhaW5lckRlZmluaXRpb25zLFxuICB9O1xuICAvLyBmaXJzdCwgbGV0J3MgZ2V0IHRoZSBuYW1lIG9mIHRoZSBmYW1pbHlcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5lc3RhYmxpc2hSZXNvdXJjZVBoeXNpY2FsTmFtZShsb2dpY2FsSWQsIHRhc2tEZWZpbml0aW9uUmVzb3VyY2U/LkZhbWlseSk7XG4gIGlmICghZmFtaWx5TmFtZU9yQXJuKSB7XG4gICAgLy8gaWYgdGhlIEZhbWlseSBwcm9wZXJ0eSBoYXMgbm90IGJlZW4gcHJvdmlkZWQsIGFuZCB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBjdXJyZW50IFN0YWNrLFxuICAgIC8vIHRoaXMgbWVhbnMgaG90c3dhcHBpbmcgaXMgbm90IHBvc3NpYmxlXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHRoZSBwaHlzaWNhbCBuYW1lIG9mIHRoZSBUYXNrIERlZmluaXRpb24gaW4gQ2xvdWRGb3JtYXRpb24gaW5jbHVkZXMgaXRzIGN1cnJlbnQgcmV2aXNpb24gbnVtYmVyIGF0IHRoZSBlbmQsXG4gIC8vIHJlbW92ZSBpdCBpZiBuZWVkZWRcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuUGFydHMgPSBmYW1pbHlOYW1lT3JBcm4uc3BsaXQoJzonKTtcbiAgY29uc3QgZmFtaWx5ID0gZmFtaWx5TmFtZU9yQXJuUGFydHMubGVuZ3RoID4gMVxuICAgIC8vIGZhbWlseU5hbWVPckFybiBpcyBhY3R1YWxseSBhbiBBUk4sIG9mIHRoZSBmb3JtYXQgJ2Fybjphd3M6ZWNzOnJlZ2lvbjphY2NvdW50OnRhc2stZGVmaW5pdGlvbi88ZmFtaWx5LW5hbWU+OjxyZXZpc2lvbi1ucj4nXG4gICAgLy8gc28sIHRha2UgdGhlIDZ0aCBlbGVtZW50LCBhdCBpbmRleCA1LCBhbmQgc3BsaXQgaXQgb24gJy8nXG4gICAgPyBmYW1pbHlOYW1lT3JBcm5QYXJ0c1s1XS5zcGxpdCgnLycpWzFdXG4gICAgLy8gb3RoZXJ3aXNlLCBmYW1pbHlOYW1lT3JBcm4gaXMganVzdCB0aGUgc2ltcGxlIG5hbWUgZXZhbHVhdGVkIGZyb20gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAgOiBmYW1pbHlOYW1lT3JBcm47XG4gIC8vIHRoZW4sIGxldCdzIGV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIFRhc2tEZWYgKHdpdGhvdXQgdGhlIEZhbWlseSBwcm9wZXJ0eSlcbiAgcmV0dXJuIHtcbiAgICAuLi5hd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgICAuLi4odGFza0RlZmluaXRpb25SZXNvdXJjZSA/PyB7fSksXG4gICAgICBGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICB9KSxcbiAgICBGYW1pbHk6IGZhbWlseSxcbiAgfTtcbn1cbiJdfQ==