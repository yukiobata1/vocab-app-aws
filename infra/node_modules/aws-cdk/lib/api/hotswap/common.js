"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportNonHotswappableResource = exports.reportNonHotswappableChange = exports.classifyChanges = exports.ClassifiedChanges = exports.lowerCaseFirstCharacter = exports.transformObjectKeys = exports.EcsHotswapProperties = exports.HotswapPropertyOverrides = exports.HotswappableChangeCandidate = exports.HotswapMode = exports.ICON = void 0;
exports.ICON = 'âœ¨';
var HotswapMode;
(function (HotswapMode) {
    /**
     * Will fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["FALL_BACK"] = "fall-back";
    /**
     * Will not fall back to CloudFormation when a non-hotswappable change is detected
     */
    HotswapMode["HOTSWAP_ONLY"] = "hotswap-only";
    /**
     * Will not attempt to hotswap anything and instead go straight to CloudFormation
     */
    HotswapMode["FULL_DEPLOYMENT"] = "full-deployment";
})(HotswapMode || (exports.HotswapMode = HotswapMode = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(logicalId, oldValue, newValue, propertyUpdates) {
        this.logicalId = logicalId;
        this.oldValue = oldValue;
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * Represents configuration property overrides for hotswap deployments
 */
class HotswapPropertyOverrides {
    constructor(ecsHotswapProperties) {
        this.ecsHotswapProperties = ecsHotswapProperties;
    }
}
exports.HotswapPropertyOverrides = HotswapPropertyOverrides;
/**
 * Represents configuration properties for ECS hotswap deployments
 */
class EcsHotswapProperties {
    constructor(minimumHealthyPercent, maximumHealthyPercent) {
        if (minimumHealthyPercent !== undefined && minimumHealthyPercent < 0) {
            throw new Error('hotswap-ecs-minimum-healthy-percent can\'t be a negative number');
        }
        if (maximumHealthyPercent !== undefined && maximumHealthyPercent < 0) {
            throw new Error('hotswap-ecs-maximum-healthy-percent can\'t be a negative number');
        }
        // In order to preserve the current behaviour, when minimumHealthyPercent is not defined, it will be set to the currently default value of 0
        if (minimumHealthyPercent == undefined) {
            this.minimumHealthyPercent = 0;
        }
        else {
            this.minimumHealthyPercent = minimumHealthyPercent;
        }
        this.maximumHealthyPercent = maximumHealthyPercent;
    }
    /**
     * Check if any hotswap properties are defined
     * @returns true if all properties are undefined, false otherwise
    */
    isEmpty() {
        return this.minimumHealthyPercent === 0 && this.maximumHealthyPercent === undefined;
    }
}
exports.EcsHotswapProperties = EcsHotswapProperties;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
exports.transformObjectKeys = transformObjectKeys;
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
class ClassifiedChanges {
    constructor(change, hotswappableProps, nonHotswappableProps) {
        this.change = change;
        this.hotswappableProps = hotswappableProps;
        this.nonHotswappableProps = nonHotswappableProps;
    }
    reportNonHotswappablePropertyChanges(ret) {
        const nonHotswappablePropNames = Object.keys(this.nonHotswappableProps);
        if (nonHotswappablePropNames.length > 0) {
            const tagOnlyChange = nonHotswappablePropNames.length === 1 && nonHotswappablePropNames[0] === 'Tags';
            reportNonHotswappableChange(ret, this.change, this.nonHotswappableProps, tagOnlyChange ? 'Tags are not hotswappable' : `resource properties '${nonHotswappablePropNames}' are not hotswappable on this resource type`);
        }
    }
    get namesOfHotswappableProps() {
        return Object.keys(this.hotswappableProps);
    }
}
exports.ClassifiedChanges = ClassifiedChanges;
function classifyChanges(xs, hotswappablePropNames) {
    const hotswappableProps = {};
    const nonHotswappableProps = {};
    for (const [name, propDiff] of Object.entries(xs.propertyUpdates)) {
        if (hotswappablePropNames.includes(name)) {
            hotswappableProps[name] = propDiff;
        }
        else {
            nonHotswappableProps[name] = propDiff;
        }
    }
    return new ClassifiedChanges(xs, hotswappableProps, nonHotswappableProps);
}
exports.classifyChanges = classifyChanges;
function reportNonHotswappableChange(ret, change, nonHotswappableProps, reason, hotswapOnlyVisible) {
    let hotswapOnlyVisibility = true;
    if (hotswapOnlyVisible === false) {
        hotswapOnlyVisibility = false;
    }
    ret.push({
        hotswappable: false,
        rejectedChanges: Object.keys(nonHotswappableProps ?? change.propertyUpdates),
        logicalId: change.logicalId,
        resourceType: change.newValue.Type,
        reason,
        hotswapOnlyVisible: hotswapOnlyVisibility,
    });
}
exports.reportNonHotswappableChange = reportNonHotswappableChange;
function reportNonHotswappableResource(change, reason) {
    return [{
            hotswappable: false,
            rejectedChanges: Object.keys(change.propertyUpdates),
            logicalId: change.logicalId,
            resourceType: change.newValue.Type,
            reason,
        }];
}
exports.reportNonHotswappableResource = reportNonHotswappableResource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdhLFFBQUEsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQThDeEIsSUFBWSxXQWVYO0FBZkQsV0FBWSxXQUFXO0lBQ3JCOztPQUVHO0lBQ0gsc0NBQXVCLENBQUE7SUFFdkI7O09BRUc7SUFDSCw0Q0FBNkIsQ0FBQTtJQUU3Qjs7T0FFRztJQUNILGtEQUFtQyxDQUFBO0FBQ3JDLENBQUMsRUFmVyxXQUFXLDJCQUFYLFdBQVcsUUFldEI7QUFFRDs7R0FFRztBQUNILE1BQWEsMkJBQTJCO0lBcUJ0QyxZQUFtQixTQUFpQixFQUFFLFFBQTJCLEVBQUUsUUFBMkIsRUFBRSxlQUEwQjtRQUN4SCxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0NBQ0Y7QUEzQkQsa0VBMkJDO0FBSUQ7O0dBRUc7QUFDSCxNQUFhLHdCQUF3QjtJQUluQyxZQUFvQixvQkFBMkM7UUFDN0QsSUFBSSxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO0lBQ25ELENBQUM7Q0FDRjtBQVBELDREQU9DO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLG9CQUFvQjtJQU0vQixZQUFvQixxQkFBOEIsRUFBRSxxQkFBOEI7UUFDaEYsSUFBSSxxQkFBcUIsS0FBSyxTQUFTLElBQUkscUJBQXFCLEdBQUcsQ0FBQyxFQUFHLENBQUM7WUFDdEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO1FBQ3JGLENBQUM7UUFDRCxJQUFJLHFCQUFxQixLQUFLLFNBQVMsSUFBSSxxQkFBcUIsR0FBRyxDQUFDLEVBQUcsQ0FBQztZQUN0RSxNQUFNLElBQUks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QUFDO0lBQ2hDLENBQUM7SUFDRCxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ1AsWUFBWSxFQUFFLEtBQUs7UUFDbkIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLElBQUksTUFBTSxDQUFDLGVBQWUsQ0FBQztRQUM1RSxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7UUFDM0IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSTtRQUNsQyxNQUFNO1FBQ04sa0JBQWtCLEVBQUUscUJBQXFCO0tBQzFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFuQkQsa0VBbUJDO0FBRUQsU0FBZ0IsNkJBQTZCLENBQzNDLE1BQW1DLEVBQ25DLE1BQWU7SUFFZixPQUFPLENBQUM7WUFDTixZQUFZLEVBQUUsS0FBSztZQUNuQixlQUFlLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDO1lBQ3BELFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztZQUMzQixZQUFZLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJO1lBQ2xDLE1BQU07U0FDUCxDQUFDLENBQUM7QUFDTCxDQUFDO0FBWEQsc0VBV0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbmV4cG9ydCBjb25zdCBJQ09OID0gJ+KcqCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG90c3dhcHBhYmxlQ2hhbmdlIHtcbiAgcmVhZG9ubHkgaG90c3dhcHBhYmxlOiB0cnVlO1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcHJvcHNDaGFuZ2VkOiBBcnJheTxzdHJpbmc+O1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgYmVpbmcgaG90c3dhcHBlZC5cbiAgICogVXNlZCB0byBzZXQgYSBjdXN0b20gVXNlci1BZ2VudCBmb3IgU0RLIGNhbGxzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgb2YgdGhlIHJlc291cmNlcyBiZWluZyBob3Rzd2FwcGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgcmVhZG9ubHkgYXBwbHk6IChzZGs6IElTREspID0+IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9uSG90c3dhcHBhYmxlQ2hhbmdlIHtcbiAgcmVhZG9ubHkgaG90c3dhcHBhYmxlOiBmYWxzZTtcbiAgcmVhZG9ubHkgcmVzb3VyY2VUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlamVjdGVkQ2hhbmdlczogQXJyYXk8c3RyaW5nPjtcbiAgcmVhZG9ubHkgbG9naWNhbElkOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUZWxscyB0aGUgdXNlciBleGFjdGx5IHdoeSB0aGlzIGNoYW5nZSB3YXMgZGVlbWVkIG5vbi1ob3Rzd2FwcGFibGUgYW5kIHdoYXQgaXRzIGxvZ2ljYWwgSUQgaXMuXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIGByZWFzb25gIHdpbGwgYmUgYXV0b2ZpbGxlZCB0byBzdGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGxpc3RlZCBpbiBgcmVqZWN0ZWRDaGFuZ2VzYCBhcmUgbm90IGhvdHN3YXBwYWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IHJlYXNvbj86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhpcyBjaGFuZ2Ugd2hlbiBsaXN0aW5nIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlcyBpbiBIT1RTV0FQX09OTFkgbW9kZS4gRG9lcyBub3QgYWZmZWN0XG4gICAqIGxpc3RpbmcgaW4gRkFMTF9CQUNLIG1vZGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGhvdHN3YXBPbmx5VmlzaWJsZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIENoYW5nZUhvdHN3YXBSZXN1bHQgPSBBcnJheTxIb3Rzd2FwcGFibGVDaGFuZ2UgfCBOb25Ib3Rzd2FwcGFibGVDaGFuZ2U+O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXMge1xuICBob3Rzd2FwcGFibGVDaGFuZ2VzOiBIb3Rzd2FwcGFibGVDaGFuZ2VbXTtcbiAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogTm9uSG90c3dhcHBhYmxlQ2hhbmdlW107XG59XG5cbmV4cG9ydCBlbnVtIEhvdHN3YXBNb2RlIHtcbiAgLyoqXG4gICAqIFdpbGwgZmFsbCBiYWNrIHRvIENsb3VkRm9ybWF0aW9uIHdoZW4gYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSBpcyBkZXRlY3RlZFxuICAgKi9cbiAgRkFMTF9CQUNLID0gJ2ZhbGwtYmFjaycsXG5cbiAgLyoqXG4gICAqIFdpbGwgbm90IGZhbGwgYmFjayB0byBDbG91ZEZvcm1hdGlvbiB3aGVuIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgaXMgZGV0ZWN0ZWRcbiAgICovXG4gIEhPVFNXQVBfT05MWSA9ICdob3Rzd2FwLW9ubHknLFxuXG4gIC8qKlxuICAgKiBXaWxsIG5vdCBhdHRlbXB0IHRvIGhvdHN3YXAgYW55dGhpbmcgYW5kIGluc3RlYWQgZ28gc3RyYWlnaHQgdG8gQ2xvdWRGb3JtYXRpb25cbiAgICovXG4gIEZVTExfREVQTE9ZTUVOVCA9ICdmdWxsLWRlcGxveW1lbnQnLFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGFuZ2UgdGhhdCBjYW4gYmUgaG90c3dhcHBlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2Ugd2hpY2ggaXMgYmVpbmcgY2hhbmdlZFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgdGhlIHJlc291cmNlIGlzIGJlaW5nIHVwZGF0ZWQgZnJvbVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG9sZFZhbHVlOiBjZm5fZGlmZi5SZXNvdXJjZTtcblxuICAvKipcbiAgICogVGhlIHZhbHVlIHRoZSByZXNvdXJjZSBpcyBiZWluZyB1cGRhdGVkIHRvXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmV3VmFsdWU6IGNmbl9kaWZmLlJlc291cmNlO1xuXG4gIC8qKlxuICAgKiBUaGUgY2hhbmdlcyBtYWRlIHRvIHRoZSByZXNvdXJjZSBwcm9wZXJ0aWVzXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcHJvcGVydHlVcGRhdGVzOiBQcm9wRGlmZnM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGxvZ2ljYWxJZDogc3RyaW5nLCBvbGRWYWx1ZTogY2ZuX2RpZmYuUmVzb3VyY2UsIG5ld1ZhbHVlOiBjZm5fZGlmZi5SZXNvdXJjZSwgcHJvcGVydHlVcGRhdGVzOiBQcm9wRGlmZnMpIHtcbiAgICB0aGlzLmxvZ2ljYWxJZCA9IGxvZ2ljYWxJZDtcbiAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgdGhpcy5uZXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucHJvcGVydHlVcGRhdGVzID0gcHJvcGVydHlVcGRhdGVzO1xuICB9XG59XG5cbnR5cGUgRXhjbHVkZSA9IHsgW2tleTogc3RyaW5nXTogRXhjbHVkZSB8IHRydWUgfVxuXG4vKipcbiAqIFJlcHJlc2VudHMgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBvdmVycmlkZXMgZm9yIGhvdHN3YXAgZGVwbG95bWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyB7XG4gIC8vIEVhY2ggc3VwcG9ydGVkIHJlc291cmNlIHR5cGUgd2lsbCBoYXZlIGl0cyBvd24gcHJvcGVydGllcy4gQ3VycmVudGx5IHRoaXMgaXMgRUNTXG4gIGVjc0hvdHN3YXBQcm9wZXJ0aWVzPzogRWNzSG90c3dhcFByb3BlcnRpZXM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yIChlY3NIb3Rzd2FwUHJvcGVydGllcz86IEVjc0hvdHN3YXBQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5lY3NIb3Rzd2FwUHJvcGVydGllcyA9IGVjc0hvdHN3YXBQcm9wZXJ0aWVzO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgZm9yIEVDUyBob3Rzd2FwIGRlcGxveW1lbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBFY3NIb3Rzd2FwUHJvcGVydGllcyB7XG4gIC8vIFRoZSBsb3dlciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHlvdXIgc2VydmljZSdzIHRhc2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIFJVTk5JTkcgc3RhdGUgZHVyaW5nIGEgZGVwbG95bWVudCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBkZXNpcmVkQ291bnRcbiAgcmVhZG9ubHkgbWluaW11bUhlYWx0aHlQZXJjZW50PzogbnVtYmVyO1xuICAvLyBUaGUgdXBwZXIgbGltaXQgb24gdGhlIG51bWJlciBvZiB5b3VyIHNlcnZpY2UncyB0YXNrcyB0aGF0IGFyZSBhbGxvd2VkIGluIHRoZSBSVU5OSU5HIG9yIFBFTkRJTkcgc3RhdGUgZHVyaW5nIGEgZGVwbG95bWVudCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBkZXNpcmVkQ291bnRcbiAgcmVhZG9ubHkgbWF4aW11bUhlYWx0aHlQZXJjZW50PzogbnVtYmVyO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvciAobWluaW11bUhlYWx0aHlQZXJjZW50PzogbnVtYmVyLCBtYXhpbXVtSGVhbHRoeVBlcmNlbnQ/OiBudW1iZXIpIHtcbiAgICBpZiAobWluaW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgJiYgbWluaW11bUhlYWx0aHlQZXJjZW50IDwgMCApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaG90c3dhcC1lY3MtbWluaW11bS1oZWFsdGh5LXBlcmNlbnQgY2FuXFwndCBiZSBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAobWF4aW11bUhlYWx0aHlQZXJjZW50ICE9PSB1bmRlZmluZWQgJiYgbWF4aW11bUhlYWx0aHlQZXJjZW50IDwgMCApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaG90c3dhcC1lY3MtbWF4aW11bS1oZWFsdGh5LXBlcmNlbnQgY2FuXFwndCBiZSBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgY3VycmVudCBiZWhhdmlvdXIsIHdoZW4gbWluaW11bUhlYWx0aHlQZXJjZW50IGlzIG5vdCBkZWZpbmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudGx5IGRlZmF1bHQgdmFsdWUgb2YgMFxuICAgIGlmIChtaW5pbXVtSGVhbHRoeVBlcmNlbnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1pbmltdW1IZWFsdGh5UGVyY2VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWluaW11bUhlYWx0aHlQZXJjZW50ID0gbWluaW11bUhlYWx0aHlQZXJjZW50O1xuICAgIH1cbiAgICB0aGlzLm1heGltdW1IZWFsdGh5UGVyY2VudCA9IG1heGltdW1IZWFsdGh5UGVyY2VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbnkgaG90c3dhcCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYWxsIHByb3BlcnRpZXMgYXJlIHVuZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICovXG4gIHB1YmxpYyBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1pbmltdW1IZWFsdGh5UGVyY2VudCA9PT0gMCAmJiB0aGlzLm1heGltdW1IZWFsdGh5UGVyY2VudCA9PT0gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB0cmFuc2Zvcm1zIGFsbCBrZXlzIChyZWN1cnNpdmVseSkgaW4gdGhlIHByb3ZpZGVkIGB2YWxgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsIFRoZSBvYmplY3Qgd2hvc2Uga2V5cyBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHRyYW5zZm9ybSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gZWFjaCBrZXkuXG4gKiBAcGFyYW0gZXhjbHVkZSBUaGUga2V5cyB0aGF0IHdpbGwgbm90IGJlIHRyYW5zZm9ybWVkIGFuZCBjb3BpZWQgdG8gb3V0cHV0IGRpcmVjdGx5XG4gKiBAcmV0dXJucyBBIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgYHZhbGAsIGJ1dCB3aXRoIGFsbCBrZXlzIHRyYW5zZm9ybWVkIGFjY29yZGluZyB0byBgdHJhbnNmb3JtYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU9iamVjdEtleXModmFsOiBhbnksIHRyYW5zZm9ybTogKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcsIGV4Y2x1ZGU6IEV4Y2x1ZGUgPSB7fSk6IGFueSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIC8vIEZvciBhcnJheXMgd2UganVzdCBwYXNzIHBhcmVudCdzIGV4Y2x1ZGUgb2JqZWN0IGRpcmVjdGx5XG4gICAgLy8gc2luY2UgaXQgbWFrZXMgbm8gc2Vuc2UgdG8gc3BlY2lmeSBkaWZmZXJlbnQgZXhjbHVkZSBvcHRpb25zIGZvciBlYWNoIGFycmF5IGVsZW1lbnRcbiAgICByZXR1cm4gdmFsLm1hcCgoaW5wdXQ6IGFueSkgPT4gdHJhbnNmb3JtT2JqZWN0S2V5cyhpbnB1dCwgdHJhbnNmb3JtLCBleGNsdWRlKSk7XG4gIH1cbiAgY29uc3QgcmV0OiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgY29uc3QgY2hpbGRFeGNsdWRlID0gZXhjbHVkZVtrXTtcbiAgICBpZiAoY2hpbGRFeGNsdWRlID09PSB0cnVlKSB7XG4gICAgICAvLyB3ZSBkb24ndCB0cmFuc2Zvcm0gdGhpcyBvYmplY3QgaWYgdGhlIGtleSBpcyBzcGVjaWZpZWQgaW4gZXhjbHVkZVxuICAgICAgcmV0W3RyYW5zZm9ybShrKV0gPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHRyYW5zZm9ybU9iamVjdEtleXModiwgdHJhbnNmb3JtLCBjaGlsZEV4Y2x1ZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbG93ZXIgY2FzZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLmxlbmd0aCA+IDAgPyBgJHtzdHJbMF0udG9Mb3dlckNhc2UoKX0ke3N0ci5zbGljZSgxKX1gIDogc3RyO1xufVxuXG5leHBvcnQgdHlwZSBQcm9wRGlmZnMgPSBSZWNvcmQ8c3RyaW5nLCBjZm5fZGlmZi5Qcm9wZXJ0eURpZmZlcmVuY2U8YW55Pj47XG5cbmV4cG9ydCBjbGFzcyBDbGFzc2lmaWVkQ2hhbmdlcyB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gICAgcHVibGljIHJlYWRvbmx5IGhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMsXG4gICAgcHVibGljIHJlYWRvbmx5IG5vbkhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMsXG4gICkgeyB9XG5cbiAgcHVibGljIHJlcG9ydE5vbkhvdHN3YXBwYWJsZVByb3BlcnR5Q2hhbmdlcyhyZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQpOnZvaWQge1xuICAgIGNvbnN0IG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMubm9uSG90c3dhcHBhYmxlUHJvcHMpO1xuICAgIGlmIChub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFnT25seUNoYW5nZSA9IG5vbkhvdHN3YXBwYWJsZVByb3BOYW1lcy5sZW5ndGggPT09IDEgJiYgbm9uSG90c3dhcHBhYmxlUHJvcE5hbWVzWzBdID09PSAnVGFncyc7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UoXG4gICAgICAgIHJldCxcbiAgICAgICAgdGhpcy5jaGFuZ2UsXG4gICAgICAgIHRoaXMubm9uSG90c3dhcHBhYmxlUHJvcHMsXG4gICAgICAgIHRhZ09ubHlDaGFuZ2UgPyAnVGFncyBhcmUgbm90IGhvdHN3YXBwYWJsZScgOiBgcmVzb3VyY2UgcHJvcGVydGllcyAnJHtub25Ib3Rzd2FwcGFibGVQcm9wTmFtZXN9JyBhcmUgbm90IGhvdHN3YXBwYWJsZSBvbiB0aGlzIHJlc291cmNlIHR5cGVgLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5hbWVzT2ZIb3Rzd2FwcGFibGVQcm9wcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmeUNoYW5nZXMoXG4gIHhzOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIGhvdHN3YXBwYWJsZVByb3BOYW1lczogc3RyaW5nW10sXG4pOiBDbGFzc2lmaWVkQ2hhbmdlcyB7XG4gIGNvbnN0IGhvdHN3YXBwYWJsZVByb3BzOiBQcm9wRGlmZnMgPSB7fTtcbiAgY29uc3Qgbm9uSG90c3dhcHBhYmxlUHJvcHM6IFByb3BEaWZmcyA9IHt9O1xuXG4gIGZvciAoY29uc3QgW25hbWUsIHByb3BEaWZmXSBvZiBPYmplY3QuZW50cmllcyh4cy5wcm9wZXJ0eVVwZGF0ZXMpKSB7XG4gICAgaWYgKGhvdHN3YXBwYWJsZVByb3BOYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgaG90c3dhcHBhYmxlUHJvcHNbbmFtZV0gPSBwcm9wRGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9uSG90c3dhcHBhYmxlUHJvcHNbbmFtZV0gPSBwcm9wRGlmZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IENsYXNzaWZpZWRDaGFuZ2VzKHhzLCBob3Rzd2FwcGFibGVQcm9wcywgbm9uSG90c3dhcHBhYmxlUHJvcHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKFxuICByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQsXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuICBub25Ib3Rzd2FwcGFibGVQcm9wcz86IFByb3BEaWZmcyxcbiAgcmVhc29uPzogc3RyaW5nLFxuICBob3Rzd2FwT25seVZpc2libGU/OiBib29sZWFuLFxuKTogdm9pZCB7XG4gIGxldCBob3Rzd2FwT25seVZpc2liaWxpdHkgPSB0cnVlO1xuICBpZiAoaG90c3dhcE9ubHlWaXNpYmxlID09PSBmYWxzZSkge1xuICAgIGhvdHN3YXBPbmx5VmlzaWJpbGl0eSA9IGZhbHNlO1xuICB9XG4gIHJldC5wdXNoKHtcbiAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgIHJlamVjdGVkQ2hhbmdlczogT2JqZWN0LmtleXMobm9uSG90c3dhcHBhYmxlUHJvcHMgPz8gY2hhbmdlLnByb3BlcnR5VXBkYXRlcyksXG4gICAgbG9naWNhbElkOiBjaGFuZ2UubG9naWNhbElkLFxuICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlLlR5cGUsXG4gICAgcmVhc29uLFxuICAgIGhvdHN3YXBPbmx5VmlzaWJsZTogaG90c3dhcE9ubHlWaXNpYmlsaXR5LFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydE5vbkhvdHN3YXBwYWJsZVJlc291cmNlKFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSxcbiAgcmVhc29uPzogc3RyaW5nLFxuKTogQ2hhbmdlSG90c3dhcFJlc3VsdCB7XG4gIHJldHVybiBbe1xuICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgcmVqZWN0ZWRDaGFuZ2VzOiBPYmplY3Qua2V5cyhjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSxcbiAgICBsb2dpY2FsSWQ6IGNoYW5nZS5sb2dpY2FsSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICByZWFzb24sXG4gIH1dO1xufVxuIl19